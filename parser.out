Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BASE
    BREAK
    CASE
    CATCH
    CLASS
    COMMENT
    CONST
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLAR
    DYNAMIC
    ELSE
    ENUM
    EQUALS
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINAL
    FINALLY
    FOR
    FUNCTION
    GET
    HIDE
    IF
    IF_NULL
    IMPLEMENTS
    IN
    INTERFACE
    IS
    LATE
    LBRACKET
    LESS_EQUAL
    LESS_THAN
    LIBRARY
    MIXIN
    MORE_EQUAL
    MORE_THAN
    MULTILINE_COMMENT
    NOT_EQUAL
    NULL
    OF
    ON
    OPERATOR
    PART
    RBRACKET
    REQUIRED
    RETHROW
    RETURN
    SEALED
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THIS
    THROW
    TRY
    TYPE
    TYPEDEF
    VOID
    WHEN
    WHILE
    WITH
    YIELD

Grammar

Rule 0     S' -> body
Rule 1     body -> instruction SEMICOLON body
Rule 2     body -> instruction SEMICOLON
Rule 3     body -> functionDeclaration body
Rule 4     body -> functionDeclaration
Rule 5     import -> IMPORT STRING
Rule 6     instruction -> functionCall
Rule 7     instruction -> variableDeclarationUninitialized
Rule 8     instruction -> variableDeclarationInitialized
Rule 9     instruction -> variableMutation
Rule 10    instruction -> import
Rule 11    non_nullable_datatype -> INT_TYPE
Rule 12    non_nullable_datatype -> DOUBLE_TYPE
Rule 13    non_nullable_datatype -> NUM_TYPE
Rule 14    non_nullable_datatype -> BOOL_TYPE
Rule 15    non_nullable_datatype -> STRING_TYPE
Rule 16    non_nullable_datatype -> LIST_TYPE
Rule 17    non_nullable_datatype -> MAP_TYPE
Rule 18    non_nullable_datatype -> SET_TYPE
Rule 19    non_nullable_datatype -> RUNES_TYPE
Rule 20    non_nullable_datatype -> SYMBOL_TYPE
Rule 21    non_nullable_datatype -> VAR_TYPE
Rule 22    nullable_datatype -> non_nullable_datatype ACCEPT_NULL
Rule 23    datatype -> nullable_datatype
Rule 24    datatype -> non_nullable_datatype
Rule 25    datatype -> recordTypes
Rule 26    variableDeclarationUninitialized -> datatype VARIABLE
Rule 27    variableInitialization -> ASSIGN value
Rule 28    variableInitialization -> ASSIGN functionCall
Rule 29    variableDeclarationInitialized -> variableDeclarationUninitialized variableInitialization
Rule 30    immediateAssign -> SUM_ASSIGN
Rule 31    immediateAssign -> SUB_ASSIGN
Rule 32    immediateAssign -> MUL_ASSIGN
Rule 33    immediateAssign -> DIV_ASSIGN
Rule 34    immediateAssign -> MOD_ASSIGN
Rule 35    immediateAssign -> AND_ASSIGN
Rule 36    immediateAssign -> OR_ASSIGN
Rule 37    immediateAssign -> XOR_ASSIGN
Rule 38    immediateAssign -> LSHIFT_ASSIGN
Rule 39    immediateAssign -> RSHIFT_ASSIGN
Rule 40    immediateAssign -> RUNSIGNED_SHIFT_ASSIGN
Rule 41    variableMutation -> VARIABLE variableInitialization
Rule 42    variableMutation -> VARIABLE immediateAssign value
Rule 43    functionCall -> prototype
Rule 44    functionCall -> VARIABLE DOT prototype
Rule 45    functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE
Rule 46    parameters -> datatype VARIABLE COMMA parameters
Rule 47    parameters -> datatype VARIABLE
Rule 48    values -> value COMMA values
Rule 49    values -> value
Rule 50    prototype -> FUNC_START values RPAREN
Rule 51    prototype -> FUNC_START RPAREN
Rule 52    object -> NEW prototype
Rule 53    boolean -> TRUE
Rule 54    boolean -> FALSE
Rule 55    number -> INTEGER
Rule 56    number -> DOUBLE
Rule 57    arithmeticOperator -> PLUS
Rule 58    arithmeticOperator -> MINUS
Rule 59    arithmeticOperator -> TIMES
Rule 60    arithmeticOperator -> DIVIDE
Rule 61    arithmeticOperator -> MOD
Rule 62    logicOperator -> LOGICAL_AND
Rule 63    logicOperator -> LOGICAL_OR
Rule 64    bitwiseOperator -> BITWISE_AND
Rule 65    bitwiseOperator -> BITWISE_OR
Rule 66    bitwiseOperator -> BITWISE_XOR
Rule 67    value -> number
Rule 68    value -> MINUS number
Rule 69    value -> object
Rule 70    value -> arithmeticExpression
Rule 71    value -> MINUS LPAREN arithmeticExpression RPAREN
Rule 72    value -> bitwiseExpression
Rule 73    value -> MINUS LPAREN bitwiseExpression RPAREN
Rule 74    value -> logicExpression
Rule 75    value -> NOT LPAREN logicExpression RPAREN
Rule 76    value -> STRING
Rule 77    value -> VARIABLE
Rule 78    value -> NOT VARIABLE
Rule 79    value -> boolean
Rule 80    value -> NOT boolean
Rule 81    value -> variableValuePair
Rule 82    value -> tuple
Rule 83    logicExpression -> value logicOperator value
Rule 84    logicExpression -> LPAREN value logicOperator value RPAREN
Rule 85    arithmeticExpression -> value arithmeticOperator value
Rule 86    arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN
Rule 87    bitwiseExpression -> value bitwiseOperator value
Rule 88    bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN
Rule 89    recordTypes -> LPAREN multipleDatatypes RPAREN
Rule 90    recordTypes -> LPAREN parameters RPAREN
Rule 91    recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN
Rule 92    recordTypeAnnotation -> datatype VARIABLE COMMA recordTypeAnnotation
Rule 93    recordTypeAnnotation -> datatype VARIABLE
Rule 94    multipleDatatypes -> datatype COMMA multipleDatatypes
Rule 95    multipleDatatypes -> datatype
Rule 96    variableValuePair -> VARIABLE COLON value
Rule 97    tuple -> LPAREN values RPAREN

Terminals, with rules where they appear

ABSTRACT             : 
ACCEPT_NULL          : 22
AND_ASSIGN           : 35
AS                   : 
ASSERT               : 
ASSIGN               : 27 28
ASYNC                : 
AWAIT                : 
BASE                 : 
BITWISE_AND          : 64
BITWISE_OR           : 65
BITWISE_XOR          : 66
BOOL_TYPE            : 14
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 96
COMMA                : 46 48 92 94
COMMENT              : 
CONST                : 
CONTINUE             : 
COVARIANT            : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 60
DIV_ASSIGN           : 33
DO                   : 
DOLLAR               : 
DOT                  : 44
DOUBLE               : 56
DOUBLE_TYPE          : 12
DYNAMIC              : 
ELSE                 : 
ENUM                 : 
EQUALS               : 
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 54
FINAL                : 
FINALLY              : 
FOR                  : 
FUNCTION             : 
FUNC_START           : 45 50 51
GET                  : 
HIDE                 : 
IF                   : 
IF_NULL              : 
IMPLEMENTS           : 
IMPORT               : 5
IN                   : 
INTEGER              : 55
INTERFACE            : 
INT_TYPE             : 11
IS                   : 
LATE                 : 
LBRACE               : 45 91
LBRACKET             : 
LESS_EQUAL           : 
LESS_THAN            : 
LIBRARY              : 
LIST_TYPE            : 16
LOGICAL_AND          : 62
LOGICAL_OR           : 63
LPAREN               : 71 73 75 84 86 88 89 90 91 97
LSHIFT_ASSIGN        : 38
MAP_TYPE             : 17
MINUS                : 58 68 71 73
MIXIN                : 
MOD                  : 61
MOD_ASSIGN           : 34
MORE_EQUAL           : 
MORE_THAN            : 
MULTILINE_COMMENT    : 
MUL_ASSIGN           : 32
NEW                  : 52
NOT                  : 75 78 80
NOT_EQUAL            : 
NULL                 : 
NUM_TYPE             : 13
OF                   : 
ON                   : 
OPERATOR             : 
OR_ASSIGN            : 36
PART                 : 
PLUS                 : 57
RBRACE               : 45 91
RBRACKET             : 
REQUIRED             : 
RETHROW              : 
RETURN               : 
RPAREN               : 45 50 51 71 73 75 84 86 88 89 90 91 97
RSHIFT_ASSIGN        : 39
RUNES_TYPE           : 19
RUNSIGNED_SHIFT_ASSIGN : 40
SEALED               : 
SEMICOLON            : 1 2
SET                  : 
SET_TYPE             : 18
SHOW                 : 
STATIC               : 
STRING               : 5 76
STRING_TYPE          : 15
SUB_ASSIGN           : 31
SUM_ASSIGN           : 30
SUPER                : 
SWITCH               : 
SYMBOL_TYPE          : 20
SYNC                 : 
THIS                 : 
THROW                : 
TIMES                : 59
TRUE                 : 53
TRY                  : 
TYPE                 : 
TYPEDEF              : 
VARIABLE             : 26 41 42 44 46 47 77 78 92 93 96
VAR_TYPE             : 21
VOID                 : 
WHEN                 : 
WHILE                : 
WITH                 : 
XOR_ASSIGN           : 37
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmeticExpression : 70 71
arithmeticOperator   : 85 86
bitwiseExpression    : 72 73
bitwiseOperator      : 87 88
body                 : 1 3 45 0
boolean              : 79 80
datatype             : 26 45 46 47 92 93 94 95
functionCall         : 6 28
functionDeclaration  : 3 4
immediateAssign      : 42
import               : 10
instruction          : 1 2
logicExpression      : 74 75
logicOperator        : 83 84
multipleDatatypes    : 89 94
non_nullable_datatype : 22 24
nullable_datatype    : 23
number               : 67 68
object               : 69
parameters           : 45 46 90
prototype            : 43 44 52
recordTypeAnnotation : 91 92
recordTypes          : 25
tuple                : 82
value                : 27 42 48 49 83 83 84 84 85 85 86 86 87 87 88 88 96
values               : 48 50 97
variableDeclarationInitialized : 8
variableDeclarationUninitialized : 7 29
variableInitialization : 29 41
variableMutation     : 9
variableValuePair    : 81

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . functionDeclaration body
    (4) body -> . functionDeclaration
    (6) instruction -> . functionCall
    (7) instruction -> . variableDeclarationUninitialized
    (8) instruction -> . variableDeclarationInitialized
    (9) instruction -> . variableMutation
    (10) instruction -> . import
    (45) functionDeclaration -> . datatype FUNC_START parameters RPAREN LBRACE body RBRACE
    (43) functionCall -> . prototype
    (44) functionCall -> . VARIABLE DOT prototype
    (26) variableDeclarationUninitialized -> . datatype VARIABLE
    (29) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (41) variableMutation -> . VARIABLE variableInitialization
    (42) variableMutation -> . VARIABLE immediateAssign value
    (5) import -> . IMPORT STRING
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 13
    FUNC_START      shift and go to state 10
    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    body                           shift and go to state 1
    instruction                    shift and go to state 2
    functionDeclaration            shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    datatype                       shift and go to state 9
    prototype                      shift and go to state 11
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 1

    (0) S' -> body .



state 2

    (1) body -> instruction . SEMICOLON body
    (2) body -> instruction . SEMICOLON

    SEMICOLON       shift and go to state 29


state 3

    (3) body -> functionDeclaration . body
    (4) body -> functionDeclaration .
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . functionDeclaration body
    (4) body -> . functionDeclaration
    (6) instruction -> . functionCall
    (7) instruction -> . variableDeclarationUninitialized
    (8) instruction -> . variableDeclarationInitialized
    (9) instruction -> . variableMutation
    (10) instruction -> . import
    (45) functionDeclaration -> . datatype FUNC_START parameters RPAREN LBRACE body RBRACE
    (43) functionCall -> . prototype
    (44) functionCall -> . VARIABLE DOT prototype
    (26) variableDeclarationUninitialized -> . datatype VARIABLE
    (29) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (41) variableMutation -> . VARIABLE variableInitialization
    (42) variableMutation -> . VARIABLE immediateAssign value
    (5) import -> . IMPORT STRING
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    $end            reduce using rule 4 (body -> functionDeclaration .)
    RBRACE          reduce using rule 4 (body -> functionDeclaration .)
    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 13
    FUNC_START      shift and go to state 10
    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    functionDeclaration            shift and go to state 3
    body                           shift and go to state 30
    instruction                    shift and go to state 2
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    datatype                       shift and go to state 9
    prototype                      shift and go to state 11
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 4

    (6) instruction -> functionCall .

    SEMICOLON       reduce using rule 6 (instruction -> functionCall .)


state 5

    (7) instruction -> variableDeclarationUninitialized .
    (29) variableDeclarationInitialized -> variableDeclarationUninitialized . variableInitialization
    (27) variableInitialization -> . ASSIGN value
    (28) variableInitialization -> . ASSIGN functionCall

    SEMICOLON       reduce using rule 7 (instruction -> variableDeclarationUninitialized .)
    ASSIGN          shift and go to state 32

    variableInitialization         shift and go to state 31

state 6

    (8) instruction -> variableDeclarationInitialized .

    SEMICOLON       reduce using rule 8 (instruction -> variableDeclarationInitialized .)


state 7

    (9) instruction -> variableMutation .

    SEMICOLON       reduce using rule 9 (instruction -> variableMutation .)


state 8

    (10) instruction -> import .

    SEMICOLON       reduce using rule 10 (instruction -> import .)


state 9

    (45) functionDeclaration -> datatype . FUNC_START parameters RPAREN LBRACE body RBRACE
    (26) variableDeclarationUninitialized -> datatype . VARIABLE

    FUNC_START      shift and go to state 33
    VARIABLE        shift and go to state 34


state 10

    (50) prototype -> FUNC_START . values RPAREN
    (51) prototype -> FUNC_START . RPAREN
    (48) values -> . value COMMA values
    (49) values -> . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    RPAREN          shift and go to state 36
    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    values                         shift and go to state 35
    value                          shift and go to state 37
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 11

    (43) functionCall -> prototype .

    SEMICOLON       reduce using rule 43 (functionCall -> prototype .)


state 12

    (44) functionCall -> VARIABLE . DOT prototype
    (41) variableMutation -> VARIABLE . variableInitialization
    (42) variableMutation -> VARIABLE . immediateAssign value
    (27) variableInitialization -> . ASSIGN value
    (28) variableInitialization -> . ASSIGN functionCall
    (30) immediateAssign -> . SUM_ASSIGN
    (31) immediateAssign -> . SUB_ASSIGN
    (32) immediateAssign -> . MUL_ASSIGN
    (33) immediateAssign -> . DIV_ASSIGN
    (34) immediateAssign -> . MOD_ASSIGN
    (35) immediateAssign -> . AND_ASSIGN
    (36) immediateAssign -> . OR_ASSIGN
    (37) immediateAssign -> . XOR_ASSIGN
    (38) immediateAssign -> . LSHIFT_ASSIGN
    (39) immediateAssign -> . RSHIFT_ASSIGN
    (40) immediateAssign -> . RUNSIGNED_SHIFT_ASSIGN

    DOT             shift and go to state 56
    ASSIGN          shift and go to state 32
    SUM_ASSIGN      shift and go to state 59
    SUB_ASSIGN      shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    MOD_ASSIGN      shift and go to state 63
    AND_ASSIGN      shift and go to state 64
    OR_ASSIGN       shift and go to state 65
    XOR_ASSIGN      shift and go to state 66
    LSHIFT_ASSIGN   shift and go to state 67
    RSHIFT_ASSIGN   shift and go to state 68
    RUNSIGNED_SHIFT_ASSIGN shift and go to state 69

    variableInitialization         shift and go to state 57
    immediateAssign                shift and go to state 58

state 13

    (5) import -> IMPORT . STRING

    STRING          shift and go to state 70


state 14

    (23) datatype -> nullable_datatype .

    FUNC_START      reduce using rule 23 (datatype -> nullable_datatype .)
    VARIABLE        reduce using rule 23 (datatype -> nullable_datatype .)
    COMMA           reduce using rule 23 (datatype -> nullable_datatype .)
    RPAREN          reduce using rule 23 (datatype -> nullable_datatype .)


state 15

    (24) datatype -> non_nullable_datatype .
    (22) nullable_datatype -> non_nullable_datatype . ACCEPT_NULL

    FUNC_START      reduce using rule 24 (datatype -> non_nullable_datatype .)
    VARIABLE        reduce using rule 24 (datatype -> non_nullable_datatype .)
    COMMA           reduce using rule 24 (datatype -> non_nullable_datatype .)
    RPAREN          reduce using rule 24 (datatype -> non_nullable_datatype .)
    ACCEPT_NULL     shift and go to state 71


state 16

    (25) datatype -> recordTypes .

    FUNC_START      reduce using rule 25 (datatype -> recordTypes .)
    VARIABLE        reduce using rule 25 (datatype -> recordTypes .)
    COMMA           reduce using rule 25 (datatype -> recordTypes .)
    RPAREN          reduce using rule 25 (datatype -> recordTypes .)


state 17

    (11) non_nullable_datatype -> INT_TYPE .

    ACCEPT_NULL     reduce using rule 11 (non_nullable_datatype -> INT_TYPE .)
    FUNC_START      reduce using rule 11 (non_nullable_datatype -> INT_TYPE .)
    VARIABLE        reduce using rule 11 (non_nullable_datatype -> INT_TYPE .)
    COMMA           reduce using rule 11 (non_nullable_datatype -> INT_TYPE .)
    RPAREN          reduce using rule 11 (non_nullable_datatype -> INT_TYPE .)


state 18

    (12) non_nullable_datatype -> DOUBLE_TYPE .

    ACCEPT_NULL     reduce using rule 12 (non_nullable_datatype -> DOUBLE_TYPE .)
    FUNC_START      reduce using rule 12 (non_nullable_datatype -> DOUBLE_TYPE .)
    VARIABLE        reduce using rule 12 (non_nullable_datatype -> DOUBLE_TYPE .)
    COMMA           reduce using rule 12 (non_nullable_datatype -> DOUBLE_TYPE .)
    RPAREN          reduce using rule 12 (non_nullable_datatype -> DOUBLE_TYPE .)


state 19

    (13) non_nullable_datatype -> NUM_TYPE .

    ACCEPT_NULL     reduce using rule 13 (non_nullable_datatype -> NUM_TYPE .)
    FUNC_START      reduce using rule 13 (non_nullable_datatype -> NUM_TYPE .)
    VARIABLE        reduce using rule 13 (non_nullable_datatype -> NUM_TYPE .)
    COMMA           reduce using rule 13 (non_nullable_datatype -> NUM_TYPE .)
    RPAREN          reduce using rule 13 (non_nullable_datatype -> NUM_TYPE .)


state 20

    (14) non_nullable_datatype -> BOOL_TYPE .

    ACCEPT_NULL     reduce using rule 14 (non_nullable_datatype -> BOOL_TYPE .)
    FUNC_START      reduce using rule 14 (non_nullable_datatype -> BOOL_TYPE .)
    VARIABLE        reduce using rule 14 (non_nullable_datatype -> BOOL_TYPE .)
    COMMA           reduce using rule 14 (non_nullable_datatype -> BOOL_TYPE .)
    RPAREN          reduce using rule 14 (non_nullable_datatype -> BOOL_TYPE .)


state 21

    (15) non_nullable_datatype -> STRING_TYPE .

    ACCEPT_NULL     reduce using rule 15 (non_nullable_datatype -> STRING_TYPE .)
    FUNC_START      reduce using rule 15 (non_nullable_datatype -> STRING_TYPE .)
    VARIABLE        reduce using rule 15 (non_nullable_datatype -> STRING_TYPE .)
    COMMA           reduce using rule 15 (non_nullable_datatype -> STRING_TYPE .)
    RPAREN          reduce using rule 15 (non_nullable_datatype -> STRING_TYPE .)


state 22

    (16) non_nullable_datatype -> LIST_TYPE .

    ACCEPT_NULL     reduce using rule 16 (non_nullable_datatype -> LIST_TYPE .)
    FUNC_START      reduce using rule 16 (non_nullable_datatype -> LIST_TYPE .)
    VARIABLE        reduce using rule 16 (non_nullable_datatype -> LIST_TYPE .)
    COMMA           reduce using rule 16 (non_nullable_datatype -> LIST_TYPE .)
    RPAREN          reduce using rule 16 (non_nullable_datatype -> LIST_TYPE .)


state 23

    (17) non_nullable_datatype -> MAP_TYPE .

    ACCEPT_NULL     reduce using rule 17 (non_nullable_datatype -> MAP_TYPE .)
    FUNC_START      reduce using rule 17 (non_nullable_datatype -> MAP_TYPE .)
    VARIABLE        reduce using rule 17 (non_nullable_datatype -> MAP_TYPE .)
    COMMA           reduce using rule 17 (non_nullable_datatype -> MAP_TYPE .)
    RPAREN          reduce using rule 17 (non_nullable_datatype -> MAP_TYPE .)


state 24

    (18) non_nullable_datatype -> SET_TYPE .

    ACCEPT_NULL     reduce using rule 18 (non_nullable_datatype -> SET_TYPE .)
    FUNC_START      reduce using rule 18 (non_nullable_datatype -> SET_TYPE .)
    VARIABLE        reduce using rule 18 (non_nullable_datatype -> SET_TYPE .)
    COMMA           reduce using rule 18 (non_nullable_datatype -> SET_TYPE .)
    RPAREN          reduce using rule 18 (non_nullable_datatype -> SET_TYPE .)


state 25

    (19) non_nullable_datatype -> RUNES_TYPE .

    ACCEPT_NULL     reduce using rule 19 (non_nullable_datatype -> RUNES_TYPE .)
    FUNC_START      reduce using rule 19 (non_nullable_datatype -> RUNES_TYPE .)
    VARIABLE        reduce using rule 19 (non_nullable_datatype -> RUNES_TYPE .)
    COMMA           reduce using rule 19 (non_nullable_datatype -> RUNES_TYPE .)
    RPAREN          reduce using rule 19 (non_nullable_datatype -> RUNES_TYPE .)


state 26

    (20) non_nullable_datatype -> SYMBOL_TYPE .

    ACCEPT_NULL     reduce using rule 20 (non_nullable_datatype -> SYMBOL_TYPE .)
    FUNC_START      reduce using rule 20 (non_nullable_datatype -> SYMBOL_TYPE .)
    VARIABLE        reduce using rule 20 (non_nullable_datatype -> SYMBOL_TYPE .)
    COMMA           reduce using rule 20 (non_nullable_datatype -> SYMBOL_TYPE .)
    RPAREN          reduce using rule 20 (non_nullable_datatype -> SYMBOL_TYPE .)


state 27

    (21) non_nullable_datatype -> VAR_TYPE .

    ACCEPT_NULL     reduce using rule 21 (non_nullable_datatype -> VAR_TYPE .)
    FUNC_START      reduce using rule 21 (non_nullable_datatype -> VAR_TYPE .)
    VARIABLE        reduce using rule 21 (non_nullable_datatype -> VAR_TYPE .)
    COMMA           reduce using rule 21 (non_nullable_datatype -> VAR_TYPE .)
    RPAREN          reduce using rule 21 (non_nullable_datatype -> VAR_TYPE .)


state 28

    (89) recordTypes -> LPAREN . multipleDatatypes RPAREN
    (90) recordTypes -> LPAREN . parameters RPAREN
    (91) recordTypes -> LPAREN . LBRACE recordTypeAnnotation RBRACE RPAREN
    (94) multipleDatatypes -> . datatype COMMA multipleDatatypes
    (95) multipleDatatypes -> . datatype
    (46) parameters -> . datatype VARIABLE COMMA parameters
    (47) parameters -> . datatype VARIABLE
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    LBRACE          shift and go to state 74
    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    multipleDatatypes              shift and go to state 72
    parameters                     shift and go to state 73
    datatype                       shift and go to state 75
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 29

    (1) body -> instruction SEMICOLON . body
    (2) body -> instruction SEMICOLON .
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . functionDeclaration body
    (4) body -> . functionDeclaration
    (6) instruction -> . functionCall
    (7) instruction -> . variableDeclarationUninitialized
    (8) instruction -> . variableDeclarationInitialized
    (9) instruction -> . variableMutation
    (10) instruction -> . import
    (45) functionDeclaration -> . datatype FUNC_START parameters RPAREN LBRACE body RBRACE
    (43) functionCall -> . prototype
    (44) functionCall -> . VARIABLE DOT prototype
    (26) variableDeclarationUninitialized -> . datatype VARIABLE
    (29) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (41) variableMutation -> . VARIABLE variableInitialization
    (42) variableMutation -> . VARIABLE immediateAssign value
    (5) import -> . IMPORT STRING
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    $end            reduce using rule 2 (body -> instruction SEMICOLON .)
    RBRACE          reduce using rule 2 (body -> instruction SEMICOLON .)
    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 13
    FUNC_START      shift and go to state 10
    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    instruction                    shift and go to state 2
    body                           shift and go to state 76
    functionDeclaration            shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    datatype                       shift and go to state 9
    prototype                      shift and go to state 11
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 30

    (3) body -> functionDeclaration body .

    $end            reduce using rule 3 (body -> functionDeclaration body .)
    RBRACE          reduce using rule 3 (body -> functionDeclaration body .)


state 31

    (29) variableDeclarationInitialized -> variableDeclarationUninitialized variableInitialization .

    SEMICOLON       reduce using rule 29 (variableDeclarationInitialized -> variableDeclarationUninitialized variableInitialization .)


state 32

    (27) variableInitialization -> ASSIGN . value
    (28) variableInitialization -> ASSIGN . functionCall
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (43) functionCall -> . prototype
    (44) functionCall -> . VARIABLE DOT prototype
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 79
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55
    FUNC_START      shift and go to state 10

    value                          shift and go to state 77
    functionCall                   shift and go to state 78
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50
    prototype                      shift and go to state 11

state 33

    (45) functionDeclaration -> datatype FUNC_START . parameters RPAREN LBRACE body RBRACE
    (46) parameters -> . datatype VARIABLE COMMA parameters
    (47) parameters -> . datatype VARIABLE
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    datatype                       shift and go to state 80
    parameters                     shift and go to state 81
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 34

    (26) variableDeclarationUninitialized -> datatype VARIABLE .

    ASSIGN          reduce using rule 26 (variableDeclarationUninitialized -> datatype VARIABLE .)
    SEMICOLON       reduce using rule 26 (variableDeclarationUninitialized -> datatype VARIABLE .)


state 35

    (50) prototype -> FUNC_START values . RPAREN

    RPAREN          shift and go to state 82


state 36

    (51) prototype -> FUNC_START RPAREN .

    SEMICOLON       reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    COMMA           reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    PLUS            reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    MINUS           reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    TIMES           reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    DIVIDE          reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    MOD             reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    BITWISE_AND     reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    BITWISE_OR      reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    BITWISE_XOR     reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    LOGICAL_AND     reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    LOGICAL_OR      reduce using rule 51 (prototype -> FUNC_START RPAREN .)
    RPAREN          reduce using rule 51 (prototype -> FUNC_START RPAREN .)


state 37

    (48) values -> value . COMMA values
    (49) values -> value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

    COMMA           shift and go to state 83
    RPAREN          reduce using rule 49 (values -> value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 38

    (67) value -> number .

    COMMA           reduce using rule 67 (value -> number .)
    PLUS            reduce using rule 67 (value -> number .)
    MINUS           reduce using rule 67 (value -> number .)
    TIMES           reduce using rule 67 (value -> number .)
    DIVIDE          reduce using rule 67 (value -> number .)
    MOD             reduce using rule 67 (value -> number .)
    BITWISE_AND     reduce using rule 67 (value -> number .)
    BITWISE_OR      reduce using rule 67 (value -> number .)
    BITWISE_XOR     reduce using rule 67 (value -> number .)
    LOGICAL_AND     reduce using rule 67 (value -> number .)
    LOGICAL_OR      reduce using rule 67 (value -> number .)
    RPAREN          reduce using rule 67 (value -> number .)
    SEMICOLON       reduce using rule 67 (value -> number .)


state 39

    (68) value -> MINUS . number
    (71) value -> MINUS . LPAREN arithmeticExpression RPAREN
    (73) value -> MINUS . LPAREN bitwiseExpression RPAREN
    (55) number -> . INTEGER
    (56) number -> . DOUBLE

    LPAREN          shift and go to state 98
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    number                         shift and go to state 97

state 40

    (69) value -> object .

    COMMA           reduce using rule 69 (value -> object .)
    PLUS            reduce using rule 69 (value -> object .)
    MINUS           reduce using rule 69 (value -> object .)
    TIMES           reduce using rule 69 (value -> object .)
    DIVIDE          reduce using rule 69 (value -> object .)
    MOD             reduce using rule 69 (value -> object .)
    BITWISE_AND     reduce using rule 69 (value -> object .)
    BITWISE_OR      reduce using rule 69 (value -> object .)
    BITWISE_XOR     reduce using rule 69 (value -> object .)
    LOGICAL_AND     reduce using rule 69 (value -> object .)
    LOGICAL_OR      reduce using rule 69 (value -> object .)
    RPAREN          reduce using rule 69 (value -> object .)
    SEMICOLON       reduce using rule 69 (value -> object .)


state 41

    (70) value -> arithmeticExpression .

    COMMA           reduce using rule 70 (value -> arithmeticExpression .)
    PLUS            reduce using rule 70 (value -> arithmeticExpression .)
    MINUS           reduce using rule 70 (value -> arithmeticExpression .)
    TIMES           reduce using rule 70 (value -> arithmeticExpression .)
    DIVIDE          reduce using rule 70 (value -> arithmeticExpression .)
    MOD             reduce using rule 70 (value -> arithmeticExpression .)
    BITWISE_AND     reduce using rule 70 (value -> arithmeticExpression .)
    BITWISE_OR      reduce using rule 70 (value -> arithmeticExpression .)
    BITWISE_XOR     reduce using rule 70 (value -> arithmeticExpression .)
    LOGICAL_AND     reduce using rule 70 (value -> arithmeticExpression .)
    LOGICAL_OR      reduce using rule 70 (value -> arithmeticExpression .)
    RPAREN          reduce using rule 70 (value -> arithmeticExpression .)
    SEMICOLON       reduce using rule 70 (value -> arithmeticExpression .)


state 42

    (86) arithmeticExpression -> LPAREN . value arithmeticOperator value RPAREN
    (88) bitwiseExpression -> LPAREN . value bitwiseOperator value RPAREN
    (84) logicExpression -> LPAREN . value logicOperator value RPAREN
    (97) tuple -> LPAREN . values RPAREN
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (48) values -> . value COMMA values
    (49) values -> . value
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 99
    values                         shift and go to state 100
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 43

    (72) value -> bitwiseExpression .

    COMMA           reduce using rule 72 (value -> bitwiseExpression .)
    PLUS            reduce using rule 72 (value -> bitwiseExpression .)
    MINUS           reduce using rule 72 (value -> bitwiseExpression .)
    TIMES           reduce using rule 72 (value -> bitwiseExpression .)
    DIVIDE          reduce using rule 72 (value -> bitwiseExpression .)
    MOD             reduce using rule 72 (value -> bitwiseExpression .)
    BITWISE_AND     reduce using rule 72 (value -> bitwiseExpression .)
    BITWISE_OR      reduce using rule 72 (value -> bitwiseExpression .)
    BITWISE_XOR     reduce using rule 72 (value -> bitwiseExpression .)
    LOGICAL_AND     reduce using rule 72 (value -> bitwiseExpression .)
    LOGICAL_OR      reduce using rule 72 (value -> bitwiseExpression .)
    RPAREN          reduce using rule 72 (value -> bitwiseExpression .)
    SEMICOLON       reduce using rule 72 (value -> bitwiseExpression .)


state 44

    (74) value -> logicExpression .

    COMMA           reduce using rule 74 (value -> logicExpression .)
    PLUS            reduce using rule 74 (value -> logicExpression .)
    MINUS           reduce using rule 74 (value -> logicExpression .)
    TIMES           reduce using rule 74 (value -> logicExpression .)
    DIVIDE          reduce using rule 74 (value -> logicExpression .)
    MOD             reduce using rule 74 (value -> logicExpression .)
    BITWISE_AND     reduce using rule 74 (value -> logicExpression .)
    BITWISE_OR      reduce using rule 74 (value -> logicExpression .)
    BITWISE_XOR     reduce using rule 74 (value -> logicExpression .)
    LOGICAL_AND     reduce using rule 74 (value -> logicExpression .)
    LOGICAL_OR      reduce using rule 74 (value -> logicExpression .)
    RPAREN          reduce using rule 74 (value -> logicExpression .)
    SEMICOLON       reduce using rule 74 (value -> logicExpression .)


state 45

    (75) value -> NOT . LPAREN logicExpression RPAREN
    (78) value -> NOT . VARIABLE
    (80) value -> NOT . boolean
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE

    LPAREN          shift and go to state 101
    VARIABLE        shift and go to state 102
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    boolean                        shift and go to state 103

state 46

    (76) value -> STRING .

    COMMA           reduce using rule 76 (value -> STRING .)
    PLUS            reduce using rule 76 (value -> STRING .)
    MINUS           reduce using rule 76 (value -> STRING .)
    TIMES           reduce using rule 76 (value -> STRING .)
    DIVIDE          reduce using rule 76 (value -> STRING .)
    MOD             reduce using rule 76 (value -> STRING .)
    BITWISE_AND     reduce using rule 76 (value -> STRING .)
    BITWISE_OR      reduce using rule 76 (value -> STRING .)
    BITWISE_XOR     reduce using rule 76 (value -> STRING .)
    LOGICAL_AND     reduce using rule 76 (value -> STRING .)
    LOGICAL_OR      reduce using rule 76 (value -> STRING .)
    RPAREN          reduce using rule 76 (value -> STRING .)
    SEMICOLON       reduce using rule 76 (value -> STRING .)


state 47

    (77) value -> VARIABLE .
    (96) variableValuePair -> VARIABLE . COLON value

    COMMA           reduce using rule 77 (value -> VARIABLE .)
    PLUS            reduce using rule 77 (value -> VARIABLE .)
    MINUS           reduce using rule 77 (value -> VARIABLE .)
    TIMES           reduce using rule 77 (value -> VARIABLE .)
    DIVIDE          reduce using rule 77 (value -> VARIABLE .)
    MOD             reduce using rule 77 (value -> VARIABLE .)
    BITWISE_AND     reduce using rule 77 (value -> VARIABLE .)
    BITWISE_OR      reduce using rule 77 (value -> VARIABLE .)
    BITWISE_XOR     reduce using rule 77 (value -> VARIABLE .)
    LOGICAL_AND     reduce using rule 77 (value -> VARIABLE .)
    LOGICAL_OR      reduce using rule 77 (value -> VARIABLE .)
    RPAREN          reduce using rule 77 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 77 (value -> VARIABLE .)
    COLON           shift and go to state 104


state 48

    (79) value -> boolean .

    COMMA           reduce using rule 79 (value -> boolean .)
    PLUS            reduce using rule 79 (value -> boolean .)
    MINUS           reduce using rule 79 (value -> boolean .)
    TIMES           reduce using rule 79 (value -> boolean .)
    DIVIDE          reduce using rule 79 (value -> boolean .)
    MOD             reduce using rule 79 (value -> boolean .)
    BITWISE_AND     reduce using rule 79 (value -> boolean .)
    BITWISE_OR      reduce using rule 79 (value -> boolean .)
    BITWISE_XOR     reduce using rule 79 (value -> boolean .)
    LOGICAL_AND     reduce using rule 79 (value -> boolean .)
    LOGICAL_OR      reduce using rule 79 (value -> boolean .)
    RPAREN          reduce using rule 79 (value -> boolean .)
    SEMICOLON       reduce using rule 79 (value -> boolean .)


state 49

    (81) value -> variableValuePair .

    COMMA           reduce using rule 81 (value -> variableValuePair .)
    PLUS            reduce using rule 81 (value -> variableValuePair .)
    MINUS           reduce using rule 81 (value -> variableValuePair .)
    TIMES           reduce using rule 81 (value -> variableValuePair .)
    DIVIDE          reduce using rule 81 (value -> variableValuePair .)
    MOD             reduce using rule 81 (value -> variableValuePair .)
    BITWISE_AND     reduce using rule 81 (value -> variableValuePair .)
    BITWISE_OR      reduce using rule 81 (value -> variableValuePair .)
    BITWISE_XOR     reduce using rule 81 (value -> variableValuePair .)
    LOGICAL_AND     reduce using rule 81 (value -> variableValuePair .)
    LOGICAL_OR      reduce using rule 81 (value -> variableValuePair .)
    RPAREN          reduce using rule 81 (value -> variableValuePair .)
    SEMICOLON       reduce using rule 81 (value -> variableValuePair .)


state 50

    (82) value -> tuple .

    COMMA           reduce using rule 82 (value -> tuple .)
    PLUS            reduce using rule 82 (value -> tuple .)
    MINUS           reduce using rule 82 (value -> tuple .)
    TIMES           reduce using rule 82 (value -> tuple .)
    DIVIDE          reduce using rule 82 (value -> tuple .)
    MOD             reduce using rule 82 (value -> tuple .)
    BITWISE_AND     reduce using rule 82 (value -> tuple .)
    BITWISE_OR      reduce using rule 82 (value -> tuple .)
    BITWISE_XOR     reduce using rule 82 (value -> tuple .)
    LOGICAL_AND     reduce using rule 82 (value -> tuple .)
    LOGICAL_OR      reduce using rule 82 (value -> tuple .)
    RPAREN          reduce using rule 82 (value -> tuple .)
    SEMICOLON       reduce using rule 82 (value -> tuple .)


state 51

    (55) number -> INTEGER .

    COMMA           reduce using rule 55 (number -> INTEGER .)
    PLUS            reduce using rule 55 (number -> INTEGER .)
    MINUS           reduce using rule 55 (number -> INTEGER .)
    TIMES           reduce using rule 55 (number -> INTEGER .)
    DIVIDE          reduce using rule 55 (number -> INTEGER .)
    MOD             reduce using rule 55 (number -> INTEGER .)
    BITWISE_AND     reduce using rule 55 (number -> INTEGER .)
    BITWISE_OR      reduce using rule 55 (number -> INTEGER .)
    BITWISE_XOR     reduce using rule 55 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 55 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 55 (number -> INTEGER .)
    RPAREN          reduce using rule 55 (number -> INTEGER .)
    SEMICOLON       reduce using rule 55 (number -> INTEGER .)


state 52

    (56) number -> DOUBLE .

    COMMA           reduce using rule 56 (number -> DOUBLE .)
    PLUS            reduce using rule 56 (number -> DOUBLE .)
    MINUS           reduce using rule 56 (number -> DOUBLE .)
    TIMES           reduce using rule 56 (number -> DOUBLE .)
    DIVIDE          reduce using rule 56 (number -> DOUBLE .)
    MOD             reduce using rule 56 (number -> DOUBLE .)
    BITWISE_AND     reduce using rule 56 (number -> DOUBLE .)
    BITWISE_OR      reduce using rule 56 (number -> DOUBLE .)
    BITWISE_XOR     reduce using rule 56 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 56 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 56 (number -> DOUBLE .)
    RPAREN          reduce using rule 56 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 56 (number -> DOUBLE .)


state 53

    (52) object -> NEW . prototype
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN

    FUNC_START      shift and go to state 10

    prototype                      shift and go to state 105

state 54

    (53) boolean -> TRUE .

    COMMA           reduce using rule 53 (boolean -> TRUE .)
    PLUS            reduce using rule 53 (boolean -> TRUE .)
    MINUS           reduce using rule 53 (boolean -> TRUE .)
    TIMES           reduce using rule 53 (boolean -> TRUE .)
    DIVIDE          reduce using rule 53 (boolean -> TRUE .)
    MOD             reduce using rule 53 (boolean -> TRUE .)
    BITWISE_AND     reduce using rule 53 (boolean -> TRUE .)
    BITWISE_OR      reduce using rule 53 (boolean -> TRUE .)
    BITWISE_XOR     reduce using rule 53 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 53 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 53 (boolean -> TRUE .)
    RPAREN          reduce using rule 53 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 53 (boolean -> TRUE .)


state 55

    (54) boolean -> FALSE .

    COMMA           reduce using rule 54 (boolean -> FALSE .)
    PLUS            reduce using rule 54 (boolean -> FALSE .)
    MINUS           reduce using rule 54 (boolean -> FALSE .)
    TIMES           reduce using rule 54 (boolean -> FALSE .)
    DIVIDE          reduce using rule 54 (boolean -> FALSE .)
    MOD             reduce using rule 54 (boolean -> FALSE .)
    BITWISE_AND     reduce using rule 54 (boolean -> FALSE .)
    BITWISE_OR      reduce using rule 54 (boolean -> FALSE .)
    BITWISE_XOR     reduce using rule 54 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 54 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 54 (boolean -> FALSE .)
    RPAREN          reduce using rule 54 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 54 (boolean -> FALSE .)


state 56

    (44) functionCall -> VARIABLE DOT . prototype
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN

    FUNC_START      shift and go to state 10

    prototype                      shift and go to state 106

state 57

    (41) variableMutation -> VARIABLE variableInitialization .

    SEMICOLON       reduce using rule 41 (variableMutation -> VARIABLE variableInitialization .)


state 58

    (42) variableMutation -> VARIABLE immediateAssign . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 107
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 59

    (30) immediateAssign -> SUM_ASSIGN .

    MINUS           reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    NOT             reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    STRING          reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    VARIABLE        reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    INTEGER         reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    DOUBLE          reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    NEW             reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    LPAREN          reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    TRUE            reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)
    FALSE           reduce using rule 30 (immediateAssign -> SUM_ASSIGN .)


state 60

    (31) immediateAssign -> SUB_ASSIGN .

    MINUS           reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    NOT             reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    STRING          reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    VARIABLE        reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    INTEGER         reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    DOUBLE          reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    NEW             reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    LPAREN          reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    TRUE            reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)
    FALSE           reduce using rule 31 (immediateAssign -> SUB_ASSIGN .)


state 61

    (32) immediateAssign -> MUL_ASSIGN .

    MINUS           reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    NOT             reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    STRING          reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    VARIABLE        reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    INTEGER         reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    DOUBLE          reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    NEW             reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    LPAREN          reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    TRUE            reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)
    FALSE           reduce using rule 32 (immediateAssign -> MUL_ASSIGN .)


state 62

    (33) immediateAssign -> DIV_ASSIGN .

    MINUS           reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    NOT             reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    STRING          reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    VARIABLE        reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    INTEGER         reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    DOUBLE          reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    NEW             reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    LPAREN          reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    TRUE            reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)
    FALSE           reduce using rule 33 (immediateAssign -> DIV_ASSIGN .)


state 63

    (34) immediateAssign -> MOD_ASSIGN .

    MINUS           reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    NOT             reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    STRING          reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    VARIABLE        reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    INTEGER         reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    DOUBLE          reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    NEW             reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    LPAREN          reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    TRUE            reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)
    FALSE           reduce using rule 34 (immediateAssign -> MOD_ASSIGN .)


state 64

    (35) immediateAssign -> AND_ASSIGN .

    MINUS           reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    NOT             reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    STRING          reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    VARIABLE        reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    INTEGER         reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    DOUBLE          reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    NEW             reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    LPAREN          reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    TRUE            reduce using rule 35 (immediateAssign -> AND_ASSIGN .)
    FALSE           reduce using rule 35 (immediateAssign -> AND_ASSIGN .)


state 65

    (36) immediateAssign -> OR_ASSIGN .

    MINUS           reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    NOT             reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    STRING          reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    VARIABLE        reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    INTEGER         reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    DOUBLE          reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    NEW             reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    LPAREN          reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    TRUE            reduce using rule 36 (immediateAssign -> OR_ASSIGN .)
    FALSE           reduce using rule 36 (immediateAssign -> OR_ASSIGN .)


state 66

    (37) immediateAssign -> XOR_ASSIGN .

    MINUS           reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    NOT             reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    STRING          reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    VARIABLE        reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    INTEGER         reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    DOUBLE          reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    NEW             reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    LPAREN          reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    TRUE            reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)
    FALSE           reduce using rule 37 (immediateAssign -> XOR_ASSIGN .)


state 67

    (38) immediateAssign -> LSHIFT_ASSIGN .

    MINUS           reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    NOT             reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    VARIABLE        reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    INTEGER         reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    DOUBLE          reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    NEW             reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    LPAREN          reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    TRUE            reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)
    FALSE           reduce using rule 38 (immediateAssign -> LSHIFT_ASSIGN .)


state 68

    (39) immediateAssign -> RSHIFT_ASSIGN .

    MINUS           reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    NOT             reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    VARIABLE        reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    INTEGER         reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    DOUBLE          reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    NEW             reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    LPAREN          reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    TRUE            reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)
    FALSE           reduce using rule 39 (immediateAssign -> RSHIFT_ASSIGN .)


state 69

    (40) immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .

    MINUS           reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    NOT             reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    STRING          reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    VARIABLE        reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    INTEGER         reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    DOUBLE          reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    NEW             reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    LPAREN          reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    TRUE            reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    FALSE           reduce using rule 40 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)


state 70

    (5) import -> IMPORT STRING .

    SEMICOLON       reduce using rule 5 (import -> IMPORT STRING .)


state 71

    (22) nullable_datatype -> non_nullable_datatype ACCEPT_NULL .

    FUNC_START      reduce using rule 22 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)
    VARIABLE        reduce using rule 22 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)
    COMMA           reduce using rule 22 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)
    RPAREN          reduce using rule 22 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)


state 72

    (89) recordTypes -> LPAREN multipleDatatypes . RPAREN

    RPAREN          shift and go to state 108


state 73

    (90) recordTypes -> LPAREN parameters . RPAREN

    RPAREN          shift and go to state 109


state 74

    (91) recordTypes -> LPAREN LBRACE . recordTypeAnnotation RBRACE RPAREN
    (92) recordTypeAnnotation -> . datatype VARIABLE COMMA recordTypeAnnotation
    (93) recordTypeAnnotation -> . datatype VARIABLE
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    recordTypeAnnotation           shift and go to state 110
    datatype                       shift and go to state 111
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 75

    (94) multipleDatatypes -> datatype . COMMA multipleDatatypes
    (95) multipleDatatypes -> datatype .
    (46) parameters -> datatype . VARIABLE COMMA parameters
    (47) parameters -> datatype . VARIABLE

    COMMA           shift and go to state 112
    RPAREN          reduce using rule 95 (multipleDatatypes -> datatype .)
    VARIABLE        shift and go to state 113


state 76

    (1) body -> instruction SEMICOLON body .

    $end            reduce using rule 1 (body -> instruction SEMICOLON body .)
    RBRACE          reduce using rule 1 (body -> instruction SEMICOLON body .)


state 77

    (27) variableInitialization -> ASSIGN value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

    SEMICOLON       reduce using rule 27 (variableInitialization -> ASSIGN value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 78

    (28) variableInitialization -> ASSIGN functionCall .

    SEMICOLON       reduce using rule 28 (variableInitialization -> ASSIGN functionCall .)


state 79

    (77) value -> VARIABLE .
    (44) functionCall -> VARIABLE . DOT prototype
    (96) variableValuePair -> VARIABLE . COLON value

    PLUS            reduce using rule 77 (value -> VARIABLE .)
    MINUS           reduce using rule 77 (value -> VARIABLE .)
    TIMES           reduce using rule 77 (value -> VARIABLE .)
    DIVIDE          reduce using rule 77 (value -> VARIABLE .)
    MOD             reduce using rule 77 (value -> VARIABLE .)
    BITWISE_AND     reduce using rule 77 (value -> VARIABLE .)
    BITWISE_OR      reduce using rule 77 (value -> VARIABLE .)
    BITWISE_XOR     reduce using rule 77 (value -> VARIABLE .)
    LOGICAL_AND     reduce using rule 77 (value -> VARIABLE .)
    LOGICAL_OR      reduce using rule 77 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 77 (value -> VARIABLE .)
    DOT             shift and go to state 56
    COLON           shift and go to state 104


state 80

    (46) parameters -> datatype . VARIABLE COMMA parameters
    (47) parameters -> datatype . VARIABLE

    VARIABLE        shift and go to state 113


state 81

    (45) functionDeclaration -> datatype FUNC_START parameters . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 114


state 82

    (50) prototype -> FUNC_START values RPAREN .

    SEMICOLON       reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    COMMA           reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    PLUS            reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    MINUS           reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    TIMES           reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    DIVIDE          reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    MOD             reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    BITWISE_AND     reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    BITWISE_OR      reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    BITWISE_XOR     reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    LOGICAL_AND     reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    LOGICAL_OR      reduce using rule 50 (prototype -> FUNC_START values RPAREN .)
    RPAREN          reduce using rule 50 (prototype -> FUNC_START values RPAREN .)


state 83

    (48) values -> value COMMA . values
    (48) values -> . value COMMA values
    (49) values -> . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 37
    values                         shift and go to state 115
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 84

    (85) arithmeticExpression -> value arithmeticOperator . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 116
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 85

    (87) bitwiseExpression -> value bitwiseOperator . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 117
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 86

    (83) logicExpression -> value logicOperator . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 118
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 87

    (57) arithmeticOperator -> PLUS .

    MINUS           reduce using rule 57 (arithmeticOperator -> PLUS .)
    NOT             reduce using rule 57 (arithmeticOperator -> PLUS .)
    STRING          reduce using rule 57 (arithmeticOperator -> PLUS .)
    VARIABLE        reduce using rule 57 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 57 (arithmeticOperator -> PLUS .)
    DOUBLE          reduce using rule 57 (arithmeticOperator -> PLUS .)
    NEW             reduce using rule 57 (arithmeticOperator -> PLUS .)
    LPAREN          reduce using rule 57 (arithmeticOperator -> PLUS .)
    TRUE            reduce using rule 57 (arithmeticOperator -> PLUS .)
    FALSE           reduce using rule 57 (arithmeticOperator -> PLUS .)


state 88

    (58) arithmeticOperator -> MINUS .

    MINUS           reduce using rule 58 (arithmeticOperator -> MINUS .)
    NOT             reduce using rule 58 (arithmeticOperator -> MINUS .)
    STRING          reduce using rule 58 (arithmeticOperator -> MINUS .)
    VARIABLE        reduce using rule 58 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 58 (arithmeticOperator -> MINUS .)
    DOUBLE          reduce using rule 58 (arithmeticOperator -> MINUS .)
    NEW             reduce using rule 58 (arithmeticOperator -> MINUS .)
    LPAREN          reduce using rule 58 (arithmeticOperator -> MINUS .)
    TRUE            reduce using rule 58 (arithmeticOperator -> MINUS .)
    FALSE           reduce using rule 58 (arithmeticOperator -> MINUS .)


state 89

    (59) arithmeticOperator -> TIMES .

    MINUS           reduce using rule 59 (arithmeticOperator -> TIMES .)
    NOT             reduce using rule 59 (arithmeticOperator -> TIMES .)
    STRING          reduce using rule 59 (arithmeticOperator -> TIMES .)
    VARIABLE        reduce using rule 59 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 59 (arithmeticOperator -> TIMES .)
    DOUBLE          reduce using rule 59 (arithmeticOperator -> TIMES .)
    NEW             reduce using rule 59 (arithmeticOperator -> TIMES .)
    LPAREN          reduce using rule 59 (arithmeticOperator -> TIMES .)
    TRUE            reduce using rule 59 (arithmeticOperator -> TIMES .)
    FALSE           reduce using rule 59 (arithmeticOperator -> TIMES .)


state 90

    (60) arithmeticOperator -> DIVIDE .

    MINUS           reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    NOT             reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    STRING          reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    VARIABLE        reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    DOUBLE          reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    NEW             reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    LPAREN          reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    TRUE            reduce using rule 60 (arithmeticOperator -> DIVIDE .)
    FALSE           reduce using rule 60 (arithmeticOperator -> DIVIDE .)


state 91

    (61) arithmeticOperator -> MOD .

    MINUS           reduce using rule 61 (arithmeticOperator -> MOD .)
    NOT             reduce using rule 61 (arithmeticOperator -> MOD .)
    STRING          reduce using rule 61 (arithmeticOperator -> MOD .)
    VARIABLE        reduce using rule 61 (arithmeticOperator -> MOD .)
    INTEGER         reduce using rule 61 (arithmeticOperator -> MOD .)
    DOUBLE          reduce using rule 61 (arithmeticOperator -> MOD .)
    NEW             reduce using rule 61 (arithmeticOperator -> MOD .)
    LPAREN          reduce using rule 61 (arithmeticOperator -> MOD .)
    TRUE            reduce using rule 61 (arithmeticOperator -> MOD .)
    FALSE           reduce using rule 61 (arithmeticOperator -> MOD .)


state 92

    (64) bitwiseOperator -> BITWISE_AND .

    MINUS           reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    NOT             reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    STRING          reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    VARIABLE        reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    INTEGER         reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    DOUBLE          reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    NEW             reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    LPAREN          reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    TRUE            reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)
    FALSE           reduce using rule 64 (bitwiseOperator -> BITWISE_AND .)


state 93

    (65) bitwiseOperator -> BITWISE_OR .

    MINUS           reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    NOT             reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    STRING          reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    VARIABLE        reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    INTEGER         reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    DOUBLE          reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    NEW             reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    LPAREN          reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    TRUE            reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)
    FALSE           reduce using rule 65 (bitwiseOperator -> BITWISE_OR .)


state 94

    (66) bitwiseOperator -> BITWISE_XOR .

    MINUS           reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    NOT             reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    STRING          reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    VARIABLE        reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    INTEGER         reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    DOUBLE          reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    NEW             reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    LPAREN          reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    TRUE            reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)
    FALSE           reduce using rule 66 (bitwiseOperator -> BITWISE_XOR .)


state 95

    (62) logicOperator -> LOGICAL_AND .

    MINUS           reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    NOT             reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    STRING          reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    VARIABLE        reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    INTEGER         reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    DOUBLE          reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    NEW             reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    LPAREN          reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    TRUE            reduce using rule 62 (logicOperator -> LOGICAL_AND .)
    FALSE           reduce using rule 62 (logicOperator -> LOGICAL_AND .)


state 96

    (63) logicOperator -> LOGICAL_OR .

    MINUS           reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    NOT             reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    STRING          reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    VARIABLE        reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    INTEGER         reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    DOUBLE          reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    NEW             reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    LPAREN          reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    TRUE            reduce using rule 63 (logicOperator -> LOGICAL_OR .)
    FALSE           reduce using rule 63 (logicOperator -> LOGICAL_OR .)


state 97

    (68) value -> MINUS number .

    COMMA           reduce using rule 68 (value -> MINUS number .)
    PLUS            reduce using rule 68 (value -> MINUS number .)
    MINUS           reduce using rule 68 (value -> MINUS number .)
    TIMES           reduce using rule 68 (value -> MINUS number .)
    DIVIDE          reduce using rule 68 (value -> MINUS number .)
    MOD             reduce using rule 68 (value -> MINUS number .)
    BITWISE_AND     reduce using rule 68 (value -> MINUS number .)
    BITWISE_OR      reduce using rule 68 (value -> MINUS number .)
    BITWISE_XOR     reduce using rule 68 (value -> MINUS number .)
    LOGICAL_AND     reduce using rule 68 (value -> MINUS number .)
    LOGICAL_OR      reduce using rule 68 (value -> MINUS number .)
    RPAREN          reduce using rule 68 (value -> MINUS number .)
    SEMICOLON       reduce using rule 68 (value -> MINUS number .)


state 98

    (71) value -> MINUS LPAREN . arithmeticExpression RPAREN
    (73) value -> MINUS LPAREN . bitwiseExpression RPAREN
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    LPAREN          shift and go to state 42
    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    arithmeticExpression           shift and go to state 119
    bitwiseExpression              shift and go to state 120
    value                          shift and go to state 121
    number                         shift and go to state 38
    object                         shift and go to state 40
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 99

    (86) arithmeticExpression -> LPAREN value . arithmeticOperator value RPAREN
    (88) bitwiseExpression -> LPAREN value . bitwiseOperator value RPAREN
    (84) logicExpression -> LPAREN value . logicOperator value RPAREN
    (48) values -> value . COMMA values
    (49) values -> value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

    COMMA           shift and go to state 83
    RPAREN          reduce using rule 49 (values -> value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

    arithmeticOperator             shift and go to state 122
    bitwiseOperator                shift and go to state 123
    logicOperator                  shift and go to state 124

state 100

    (97) tuple -> LPAREN values . RPAREN

    RPAREN          shift and go to state 125


state 101

    (75) value -> NOT LPAREN . logicExpression RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    LPAREN          shift and go to state 126
    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    logicExpression                shift and go to state 127
    value                          shift and go to state 128
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 102

    (78) value -> NOT VARIABLE .

    COMMA           reduce using rule 78 (value -> NOT VARIABLE .)
    PLUS            reduce using rule 78 (value -> NOT VARIABLE .)
    MINUS           reduce using rule 78 (value -> NOT VARIABLE .)
    TIMES           reduce using rule 78 (value -> NOT VARIABLE .)
    DIVIDE          reduce using rule 78 (value -> NOT VARIABLE .)
    MOD             reduce using rule 78 (value -> NOT VARIABLE .)
    BITWISE_AND     reduce using rule 78 (value -> NOT VARIABLE .)
    BITWISE_OR      reduce using rule 78 (value -> NOT VARIABLE .)
    BITWISE_XOR     reduce using rule 78 (value -> NOT VARIABLE .)
    LOGICAL_AND     reduce using rule 78 (value -> NOT VARIABLE .)
    LOGICAL_OR      reduce using rule 78 (value -> NOT VARIABLE .)
    RPAREN          reduce using rule 78 (value -> NOT VARIABLE .)
    SEMICOLON       reduce using rule 78 (value -> NOT VARIABLE .)


state 103

    (80) value -> NOT boolean .

    COMMA           reduce using rule 80 (value -> NOT boolean .)
    PLUS            reduce using rule 80 (value -> NOT boolean .)
    MINUS           reduce using rule 80 (value -> NOT boolean .)
    TIMES           reduce using rule 80 (value -> NOT boolean .)
    DIVIDE          reduce using rule 80 (value -> NOT boolean .)
    MOD             reduce using rule 80 (value -> NOT boolean .)
    BITWISE_AND     reduce using rule 80 (value -> NOT boolean .)
    BITWISE_OR      reduce using rule 80 (value -> NOT boolean .)
    BITWISE_XOR     reduce using rule 80 (value -> NOT boolean .)
    LOGICAL_AND     reduce using rule 80 (value -> NOT boolean .)
    LOGICAL_OR      reduce using rule 80 (value -> NOT boolean .)
    RPAREN          reduce using rule 80 (value -> NOT boolean .)
    SEMICOLON       reduce using rule 80 (value -> NOT boolean .)


state 104

    (96) variableValuePair -> VARIABLE COLON . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 129
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 105

    (52) object -> NEW prototype .

    COMMA           reduce using rule 52 (object -> NEW prototype .)
    PLUS            reduce using rule 52 (object -> NEW prototype .)
    MINUS           reduce using rule 52 (object -> NEW prototype .)
    TIMES           reduce using rule 52 (object -> NEW prototype .)
    DIVIDE          reduce using rule 52 (object -> NEW prototype .)
    MOD             reduce using rule 52 (object -> NEW prototype .)
    BITWISE_AND     reduce using rule 52 (object -> NEW prototype .)
    BITWISE_OR      reduce using rule 52 (object -> NEW prototype .)
    BITWISE_XOR     reduce using rule 52 (object -> NEW prototype .)
    LOGICAL_AND     reduce using rule 52 (object -> NEW prototype .)
    LOGICAL_OR      reduce using rule 52 (object -> NEW prototype .)
    RPAREN          reduce using rule 52 (object -> NEW prototype .)
    SEMICOLON       reduce using rule 52 (object -> NEW prototype .)


state 106

    (44) functionCall -> VARIABLE DOT prototype .

    SEMICOLON       reduce using rule 44 (functionCall -> VARIABLE DOT prototype .)


state 107

    (42) variableMutation -> VARIABLE immediateAssign value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

    SEMICOLON       reduce using rule 42 (variableMutation -> VARIABLE immediateAssign value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 108

    (89) recordTypes -> LPAREN multipleDatatypes RPAREN .

    FUNC_START      reduce using rule 89 (recordTypes -> LPAREN multipleDatatypes RPAREN .)
    VARIABLE        reduce using rule 89 (recordTypes -> LPAREN multipleDatatypes RPAREN .)
    COMMA           reduce using rule 89 (recordTypes -> LPAREN multipleDatatypes RPAREN .)
    RPAREN          reduce using rule 89 (recordTypes -> LPAREN multipleDatatypes RPAREN .)


state 109

    (90) recordTypes -> LPAREN parameters RPAREN .

    FUNC_START      reduce using rule 90 (recordTypes -> LPAREN parameters RPAREN .)
    VARIABLE        reduce using rule 90 (recordTypes -> LPAREN parameters RPAREN .)
    COMMA           reduce using rule 90 (recordTypes -> LPAREN parameters RPAREN .)
    RPAREN          reduce using rule 90 (recordTypes -> LPAREN parameters RPAREN .)


state 110

    (91) recordTypes -> LPAREN LBRACE recordTypeAnnotation . RBRACE RPAREN

    RBRACE          shift and go to state 130


state 111

    (92) recordTypeAnnotation -> datatype . VARIABLE COMMA recordTypeAnnotation
    (93) recordTypeAnnotation -> datatype . VARIABLE

    VARIABLE        shift and go to state 131


state 112

    (94) multipleDatatypes -> datatype COMMA . multipleDatatypes
    (94) multipleDatatypes -> . datatype COMMA multipleDatatypes
    (95) multipleDatatypes -> . datatype
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    datatype                       shift and go to state 132
    multipleDatatypes              shift and go to state 133
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 113

    (46) parameters -> datatype VARIABLE . COMMA parameters
    (47) parameters -> datatype VARIABLE .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 47 (parameters -> datatype VARIABLE .)


state 114

    (45) functionDeclaration -> datatype FUNC_START parameters RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 135


state 115

    (48) values -> value COMMA values .

    RPAREN          reduce using rule 48 (values -> value COMMA values .)


state 116

    (85) arithmeticExpression -> value arithmeticOperator value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    COMMA           reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .)
    RPAREN          reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .)
    SEMICOLON       reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MINUS           [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! TIMES           [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! DIVIDE          [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MOD             [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 117

    (87) bitwiseExpression -> value bitwiseOperator value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    COMMA           reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .)
    RPAREN          reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .)
    SEMICOLON       reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MINUS           [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! TIMES           [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! DIVIDE          [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MOD             [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]

    bitwiseOperator                shift and go to state 85
    arithmeticOperator             shift and go to state 84
    logicOperator                  shift and go to state 86

state 118

    (83) logicExpression -> value logicOperator value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    COMMA           reduce using rule 83 (logicExpression -> value logicOperator value .)
    RPAREN          reduce using rule 83 (logicExpression -> value logicOperator value .)
    SEMICOLON       reduce using rule 83 (logicExpression -> value logicOperator value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! MINUS           [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! TIMES           [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! DIVIDE          [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! MOD             [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]

    logicOperator                  shift and go to state 86
    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85

state 119

    (71) value -> MINUS LPAREN arithmeticExpression . RPAREN
    (70) value -> arithmeticExpression .

    RPAREN          shift and go to state 136
    PLUS            reduce using rule 70 (value -> arithmeticExpression .)
    MINUS           reduce using rule 70 (value -> arithmeticExpression .)
    TIMES           reduce using rule 70 (value -> arithmeticExpression .)
    DIVIDE          reduce using rule 70 (value -> arithmeticExpression .)
    MOD             reduce using rule 70 (value -> arithmeticExpression .)
    BITWISE_AND     reduce using rule 70 (value -> arithmeticExpression .)
    BITWISE_OR      reduce using rule 70 (value -> arithmeticExpression .)
    BITWISE_XOR     reduce using rule 70 (value -> arithmeticExpression .)
    LOGICAL_AND     reduce using rule 70 (value -> arithmeticExpression .)
    LOGICAL_OR      reduce using rule 70 (value -> arithmeticExpression .)


state 120

    (73) value -> MINUS LPAREN bitwiseExpression . RPAREN
    (72) value -> bitwiseExpression .

    RPAREN          shift and go to state 137
    PLUS            reduce using rule 72 (value -> bitwiseExpression .)
    MINUS           reduce using rule 72 (value -> bitwiseExpression .)
    TIMES           reduce using rule 72 (value -> bitwiseExpression .)
    DIVIDE          reduce using rule 72 (value -> bitwiseExpression .)
    MOD             reduce using rule 72 (value -> bitwiseExpression .)
    BITWISE_AND     reduce using rule 72 (value -> bitwiseExpression .)
    BITWISE_OR      reduce using rule 72 (value -> bitwiseExpression .)
    BITWISE_XOR     reduce using rule 72 (value -> bitwiseExpression .)
    LOGICAL_AND     reduce using rule 72 (value -> bitwiseExpression .)
    LOGICAL_OR      reduce using rule 72 (value -> bitwiseExpression .)


state 121

    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 122

    (86) arithmeticExpression -> LPAREN value arithmeticOperator . value RPAREN
    (85) arithmeticExpression -> value arithmeticOperator . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 138
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 123

    (88) bitwiseExpression -> LPAREN value bitwiseOperator . value RPAREN
    (87) bitwiseExpression -> value bitwiseOperator . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 139
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 124

    (84) logicExpression -> LPAREN value logicOperator . value RPAREN
    (83) logicExpression -> value logicOperator . value
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 140
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 125

    (97) tuple -> LPAREN values RPAREN .

    COMMA           reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    PLUS            reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    MINUS           reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    TIMES           reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    DIVIDE          reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    MOD             reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    BITWISE_AND     reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    BITWISE_OR      reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    BITWISE_XOR     reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    RPAREN          reduce using rule 97 (tuple -> LPAREN values RPAREN .)
    SEMICOLON       reduce using rule 97 (tuple -> LPAREN values RPAREN .)


state 126

    (84) logicExpression -> LPAREN . value logicOperator value RPAREN
    (86) arithmeticExpression -> LPAREN . value arithmeticOperator value RPAREN
    (88) bitwiseExpression -> LPAREN . value bitwiseOperator value RPAREN
    (97) tuple -> LPAREN . values RPAREN
    (67) value -> . number
    (68) value -> . MINUS number
    (69) value -> . object
    (70) value -> . arithmeticExpression
    (71) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (72) value -> . bitwiseExpression
    (73) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (74) value -> . logicExpression
    (75) value -> . NOT LPAREN logicExpression RPAREN
    (76) value -> . STRING
    (77) value -> . VARIABLE
    (78) value -> . NOT VARIABLE
    (79) value -> . boolean
    (80) value -> . NOT boolean
    (81) value -> . variableValuePair
    (82) value -> . tuple
    (48) values -> . value COMMA values
    (49) values -> . value
    (55) number -> . INTEGER
    (56) number -> . DOUBLE
    (52) object -> . NEW prototype
    (85) arithmeticExpression -> . value arithmeticOperator value
    (86) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (87) bitwiseExpression -> . value bitwiseOperator value
    (88) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (83) logicExpression -> . value logicOperator value
    (84) logicExpression -> . LPAREN value logicOperator value RPAREN
    (53) boolean -> . TRUE
    (54) boolean -> . FALSE
    (96) variableValuePair -> . VARIABLE COLON value
    (97) tuple -> . LPAREN values RPAREN

    MINUS           shift and go to state 39
    NOT             shift and go to state 45
    STRING          shift and go to state 46
    VARIABLE        shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    NEW             shift and go to state 53
    LPAREN          shift and go to state 42
    TRUE            shift and go to state 54
    FALSE           shift and go to state 55

    value                          shift and go to state 141
    values                         shift and go to state 100
    number                         shift and go to state 38
    object                         shift and go to state 40
    arithmeticExpression           shift and go to state 41
    bitwiseExpression              shift and go to state 43
    logicExpression                shift and go to state 44
    boolean                        shift and go to state 48
    variableValuePair              shift and go to state 49
    tuple                          shift and go to state 50

state 127

    (75) value -> NOT LPAREN logicExpression . RPAREN
    (74) value -> logicExpression .

    RPAREN          shift and go to state 142
    LOGICAL_AND     reduce using rule 74 (value -> logicExpression .)
    LOGICAL_OR      reduce using rule 74 (value -> logicExpression .)
    PLUS            reduce using rule 74 (value -> logicExpression .)
    MINUS           reduce using rule 74 (value -> logicExpression .)
    TIMES           reduce using rule 74 (value -> logicExpression .)
    DIVIDE          reduce using rule 74 (value -> logicExpression .)
    MOD             reduce using rule 74 (value -> logicExpression .)
    BITWISE_AND     reduce using rule 74 (value -> logicExpression .)
    BITWISE_OR      reduce using rule 74 (value -> logicExpression .)
    BITWISE_XOR     reduce using rule 74 (value -> logicExpression .)


state 128

    (83) logicExpression -> value . logicOperator value
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR

    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94

    logicOperator                  shift and go to state 86
    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85

state 129

    (96) variableValuePair -> VARIABLE COLON value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    COMMA           reduce using rule 96 (variableValuePair -> VARIABLE COLON value .)
    RPAREN          reduce using rule 96 (variableValuePair -> VARIABLE COLON value .)
    SEMICOLON       reduce using rule 96 (variableValuePair -> VARIABLE COLON value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! MINUS           [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! TIMES           [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! DIVIDE          [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! MOD             [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! BITWISE_AND     [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! BITWISE_OR      [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! BITWISE_XOR     [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! LOGICAL_AND     [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]
  ! LOGICAL_OR      [ reduce using rule 96 (variableValuePair -> VARIABLE COLON value .) ]

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 130

    (91) recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE . RPAREN

    RPAREN          shift and go to state 143


state 131

    (92) recordTypeAnnotation -> datatype VARIABLE . COMMA recordTypeAnnotation
    (93) recordTypeAnnotation -> datatype VARIABLE .

    COMMA           shift and go to state 144
    RBRACE          reduce using rule 93 (recordTypeAnnotation -> datatype VARIABLE .)


state 132

    (94) multipleDatatypes -> datatype . COMMA multipleDatatypes
    (95) multipleDatatypes -> datatype .

    COMMA           shift and go to state 112
    RPAREN          reduce using rule 95 (multipleDatatypes -> datatype .)


state 133

    (94) multipleDatatypes -> datatype COMMA multipleDatatypes .

    RPAREN          reduce using rule 94 (multipleDatatypes -> datatype COMMA multipleDatatypes .)


state 134

    (46) parameters -> datatype VARIABLE COMMA . parameters
    (46) parameters -> . datatype VARIABLE COMMA parameters
    (47) parameters -> . datatype VARIABLE
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    datatype                       shift and go to state 80
    parameters                     shift and go to state 145
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 135

    (45) functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE . body RBRACE
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . functionDeclaration body
    (4) body -> . functionDeclaration
    (6) instruction -> . functionCall
    (7) instruction -> . variableDeclarationUninitialized
    (8) instruction -> . variableDeclarationInitialized
    (9) instruction -> . variableMutation
    (10) instruction -> . import
    (45) functionDeclaration -> . datatype FUNC_START parameters RPAREN LBRACE body RBRACE
    (43) functionCall -> . prototype
    (44) functionCall -> . VARIABLE DOT prototype
    (26) variableDeclarationUninitialized -> . datatype VARIABLE
    (29) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (41) variableMutation -> . VARIABLE variableInitialization
    (42) variableMutation -> . VARIABLE immediateAssign value
    (5) import -> . IMPORT STRING
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (50) prototype -> . FUNC_START values RPAREN
    (51) prototype -> . FUNC_START RPAREN
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 13
    FUNC_START      shift and go to state 10
    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    datatype                       shift and go to state 9
    body                           shift and go to state 146
    instruction                    shift and go to state 2
    functionDeclaration            shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    prototype                      shift and go to state 11
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 136

    (71) value -> MINUS LPAREN arithmeticExpression RPAREN .

    COMMA           reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    PLUS            reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    MINUS           reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    TIMES           reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    DIVIDE          reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    MOD             reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    BITWISE_AND     reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    BITWISE_OR      reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    BITWISE_XOR     reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    LOGICAL_AND     reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    LOGICAL_OR      reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    RPAREN          reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    SEMICOLON       reduce using rule 71 (value -> MINUS LPAREN arithmeticExpression RPAREN .)


state 137

    (73) value -> MINUS LPAREN bitwiseExpression RPAREN .

    COMMA           reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    PLUS            reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    MINUS           reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    TIMES           reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    DIVIDE          reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    MOD             reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    BITWISE_AND     reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    BITWISE_OR      reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    BITWISE_XOR     reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    LOGICAL_AND     reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    LOGICAL_OR      reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    RPAREN          reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    SEMICOLON       reduce using rule 73 (value -> MINUS LPAREN bitwiseExpression RPAREN .)


state 138

    (86) arithmeticExpression -> LPAREN value arithmeticOperator value . RPAREN
    (85) arithmeticExpression -> value arithmeticOperator value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 147
    COMMA           reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MINUS           [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! TIMES           [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! DIVIDE          [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MOD             [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! RPAREN          [ reduce using rule 85 (arithmeticExpression -> value arithmeticOperator value .) ]

    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85
    logicOperator                  shift and go to state 86

state 139

    (88) bitwiseExpression -> LPAREN value bitwiseOperator value . RPAREN
    (87) bitwiseExpression -> value bitwiseOperator value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 148
    COMMA           reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MINUS           [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! TIMES           [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! DIVIDE          [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MOD             [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! RPAREN          [ reduce using rule 87 (bitwiseExpression -> value bitwiseOperator value .) ]

    bitwiseOperator                shift and go to state 85
    arithmeticOperator             shift and go to state 84
    logicOperator                  shift and go to state 86

state 140

    (84) logicExpression -> LPAREN value logicOperator value . RPAREN
    (83) logicExpression -> value logicOperator value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 149
    COMMA           reduce using rule 83 (logicExpression -> value logicOperator value .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96

  ! PLUS            [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! MINUS           [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! TIMES           [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! DIVIDE          [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! MOD             [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]
  ! RPAREN          [ reduce using rule 83 (logicExpression -> value logicOperator value .) ]

    logicOperator                  shift and go to state 86
    arithmeticOperator             shift and go to state 84
    bitwiseOperator                shift and go to state 85

state 141

    (84) logicExpression -> LPAREN value . logicOperator value RPAREN
    (86) arithmeticExpression -> LPAREN value . arithmeticOperator value RPAREN
    (88) bitwiseExpression -> LPAREN value . bitwiseOperator value RPAREN
    (48) values -> value . COMMA values
    (49) values -> value .
    (85) arithmeticExpression -> value . arithmeticOperator value
    (87) bitwiseExpression -> value . bitwiseOperator value
    (83) logicExpression -> value . logicOperator value
    (62) logicOperator -> . LOGICAL_AND
    (63) logicOperator -> . LOGICAL_OR
    (57) arithmeticOperator -> . PLUS
    (58) arithmeticOperator -> . MINUS
    (59) arithmeticOperator -> . TIMES
    (60) arithmeticOperator -> . DIVIDE
    (61) arithmeticOperator -> . MOD
    (64) bitwiseOperator -> . BITWISE_AND
    (65) bitwiseOperator -> . BITWISE_OR
    (66) bitwiseOperator -> . BITWISE_XOR

    COMMA           shift and go to state 83
    RPAREN          reduce using rule 49 (values -> value .)
    LOGICAL_AND     shift and go to state 95
    LOGICAL_OR      shift and go to state 96
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MOD             shift and go to state 91
    BITWISE_AND     shift and go to state 92
    BITWISE_OR      shift and go to state 93
    BITWISE_XOR     shift and go to state 94

    logicOperator                  shift and go to state 124
    arithmeticOperator             shift and go to state 122
    bitwiseOperator                shift and go to state 123

state 142

    (75) value -> NOT LPAREN logicExpression RPAREN .

    COMMA           reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    PLUS            reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    MINUS           reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    TIMES           reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    DIVIDE          reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    MOD             reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    BITWISE_AND     reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    BITWISE_OR      reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    BITWISE_XOR     reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    LOGICAL_AND     reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    LOGICAL_OR      reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    RPAREN          reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)
    SEMICOLON       reduce using rule 75 (value -> NOT LPAREN logicExpression RPAREN .)


state 143

    (91) recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .

    FUNC_START      reduce using rule 91 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)
    VARIABLE        reduce using rule 91 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)
    COMMA           reduce using rule 91 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)
    RPAREN          reduce using rule 91 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)


state 144

    (92) recordTypeAnnotation -> datatype VARIABLE COMMA . recordTypeAnnotation
    (92) recordTypeAnnotation -> . datatype VARIABLE COMMA recordTypeAnnotation
    (93) recordTypeAnnotation -> . datatype VARIABLE
    (23) datatype -> . nullable_datatype
    (24) datatype -> . non_nullable_datatype
    (25) datatype -> . recordTypes
    (22) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (11) non_nullable_datatype -> . INT_TYPE
    (12) non_nullable_datatype -> . DOUBLE_TYPE
    (13) non_nullable_datatype -> . NUM_TYPE
    (14) non_nullable_datatype -> . BOOL_TYPE
    (15) non_nullable_datatype -> . STRING_TYPE
    (16) non_nullable_datatype -> . LIST_TYPE
    (17) non_nullable_datatype -> . MAP_TYPE
    (18) non_nullable_datatype -> . SET_TYPE
    (19) non_nullable_datatype -> . RUNES_TYPE
    (20) non_nullable_datatype -> . SYMBOL_TYPE
    (21) non_nullable_datatype -> . VAR_TYPE
    (89) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (90) recordTypes -> . LPAREN parameters RPAREN
    (91) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 17
    DOUBLE_TYPE     shift and go to state 18
    NUM_TYPE        shift and go to state 19
    BOOL_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21
    LIST_TYPE       shift and go to state 22
    MAP_TYPE        shift and go to state 23
    SET_TYPE        shift and go to state 24
    RUNES_TYPE      shift and go to state 25
    SYMBOL_TYPE     shift and go to state 26
    VAR_TYPE        shift and go to state 27
    LPAREN          shift and go to state 28

    datatype                       shift and go to state 111
    recordTypeAnnotation           shift and go to state 150
    nullable_datatype              shift and go to state 14
    non_nullable_datatype          shift and go to state 15
    recordTypes                    shift and go to state 16

state 145

    (46) parameters -> datatype VARIABLE COMMA parameters .

    RPAREN          reduce using rule 46 (parameters -> datatype VARIABLE COMMA parameters .)


state 146

    (45) functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 151


state 147

    (86) arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .

    COMMA           reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    PLUS            reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MINUS           reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    TIMES           reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    DIVIDE          reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MOD             reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    BITWISE_AND     reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    BITWISE_OR      reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    BITWISE_XOR     reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    LOGICAL_AND     reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    LOGICAL_OR      reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    RPAREN          reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    SEMICOLON       reduce using rule 86 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)


state 148

    (88) bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .

    COMMA           reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    PLUS            reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    MINUS           reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    TIMES           reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    DIVIDE          reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    MOD             reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    BITWISE_AND     reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    BITWISE_OR      reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    BITWISE_XOR     reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    LOGICAL_AND     reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    LOGICAL_OR      reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    RPAREN          reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    SEMICOLON       reduce using rule 88 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)


state 149

    (84) logicExpression -> LPAREN value logicOperator value RPAREN .

    COMMA           reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    PLUS            reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    MINUS           reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    TIMES           reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    DIVIDE          reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    MOD             reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    BITWISE_AND     reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    BITWISE_OR      reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    BITWISE_XOR     reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    LOGICAL_AND     reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    LOGICAL_OR      reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    RPAREN          reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    SEMICOLON       reduce using rule 84 (logicExpression -> LPAREN value logicOperator value RPAREN .)


state 150

    (92) recordTypeAnnotation -> datatype VARIABLE COMMA recordTypeAnnotation .

    RBRACE          reduce using rule 92 (recordTypeAnnotation -> datatype VARIABLE COMMA recordTypeAnnotation .)


state 151

    (45) functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    IMPORT          reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    FUNC_START      reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    INT_TYPE        reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    DOUBLE_TYPE     reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    NUM_TYPE        reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    BOOL_TYPE       reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    STRING_TYPE     reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    LIST_TYPE       reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    MAP_TYPE        reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    SET_TYPE        reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    RUNES_TYPE      reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    SYMBOL_TYPE     reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    VAR_TYPE        reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    LPAREN          reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 45 (functionDeclaration -> datatype FUNC_START parameters RPAREN LBRACE body RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for MOD in state 116 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 116 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 116 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for MOD in state 117 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 117 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 117 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for MOD in state 118 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 118 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 118 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 118 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 118 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 129 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 129 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 129 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 129 resolved as shift
WARNING: shift/reduce conflict for MOD in state 129 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 129 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 129 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 129 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 129 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 129 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 138 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 138 resolved as shift
WARNING: shift/reduce conflict for MOD in state 138 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 138 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 138 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 138 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 138 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 138 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 139 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 139 resolved as shift
WARNING: shift/reduce conflict for MOD in state 139 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 139 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 139 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 139 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 139 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 139 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 140 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 140 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 140 resolved as shift
WARNING: shift/reduce conflict for MOD in state 140 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 140 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 140 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 140 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 140 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 140 resolved as shift
