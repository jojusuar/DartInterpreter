Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BASE
    BREAK
    CASE
    CATCH
    CLASS
    COMMENT
    CONST
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLAR
    DYNAMIC
    ELSE
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINAL
    FINALLY
    FOR
    FUNCTION
    GET
    HIDE
    IF_NULL
    IMPLEMENTS
    IN
    INTERFACE
    IS
    LATE
    LBRACKET
    LIBRARY
    MIXIN
    MULTILINE_COMMENT
    NOT_EQUAL
    NULL
    OF
    ON
    OPERATOR
    PART
    RBRACKET
    REQUIRED
    RETHROW
    RETURN
    SEALED
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THIS
    THROW
    TRY
    TYPE
    TYPEDEF
    VOID
    WHEN
    WHILE
    WITH
    YIELD

Grammar

Rule 0     S' -> body
Rule 1     body -> instruction SEMICOLON body
Rule 2     body -> instruction SEMICOLON
Rule 3     body -> noSemicolonStructure body
Rule 4     body -> noSemicolonStructure
Rule 5     noSemicolonStructure -> dataStructure
Rule 6     noSemicolonStructure -> functionDeclaration
Rule 7     dataStructure -> if
Rule 8     if -> IF LPAREN value RPAREN LBRACE body RBRACE
Rule 9     import -> IMPORT STRING
Rule 10    instruction -> functionCall
Rule 11    instruction -> variableDeclarationUninitialized
Rule 12    instruction -> variableDeclarationInitialized
Rule 13    instruction -> variableMutation
Rule 14    instruction -> import
Rule 15    non_nullable_datatype -> INT_TYPE
Rule 16    non_nullable_datatype -> DOUBLE_TYPE
Rule 17    non_nullable_datatype -> NUM_TYPE
Rule 18    non_nullable_datatype -> BOOL_TYPE
Rule 19    non_nullable_datatype -> STRING_TYPE
Rule 20    non_nullable_datatype -> LIST_TYPE
Rule 21    non_nullable_datatype -> MAP_TYPE
Rule 22    non_nullable_datatype -> SET_TYPE
Rule 23    non_nullable_datatype -> RUNES_TYPE
Rule 24    non_nullable_datatype -> SYMBOL_TYPE
Rule 25    non_nullable_datatype -> VAR_TYPE
Rule 26    nullable_datatype -> non_nullable_datatype ACCEPT_NULL
Rule 27    datatype -> nullable_datatype
Rule 28    datatype -> non_nullable_datatype
Rule 29    datatype -> recordTypes
Rule 30    variableDeclarationUninitialized -> datatype VARIABLE
Rule 31    variableInitialization -> ASSIGN value
Rule 32    variableInitialization -> ASSIGN functionCall
Rule 33    variableDeclarationInitialized -> variableDeclarationUninitialized variableInitialization
Rule 34    immediateAssign -> SUM_ASSIGN
Rule 35    immediateAssign -> SUB_ASSIGN
Rule 36    immediateAssign -> MUL_ASSIGN
Rule 37    immediateAssign -> DIV_ASSIGN
Rule 38    immediateAssign -> MOD_ASSIGN
Rule 39    immediateAssign -> AND_ASSIGN
Rule 40    immediateAssign -> OR_ASSIGN
Rule 41    immediateAssign -> XOR_ASSIGN
Rule 42    immediateAssign -> LSHIFT_ASSIGN
Rule 43    immediateAssign -> RSHIFT_ASSIGN
Rule 44    immediateAssign -> RUNSIGNED_SHIFT_ASSIGN
Rule 45    variableMutation -> VARIABLE variableInitialization
Rule 46    variableMutation -> VARIABLE immediateAssign value
Rule 47    functionCall -> prototype
Rule 48    functionCall -> VARIABLE DOT prototype
Rule 49    functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE
Rule 50    parameters -> datatype VARIABLE COMMA parameters
Rule 51    parameters -> datatype VARIABLE
Rule 52    values -> value COMMA values
Rule 53    values -> value
Rule 54    prototype -> VARIABLE LPAREN values RPAREN
Rule 55    prototype -> VARIABLE LPAREN RPAREN
Rule 56    object -> NEW prototype
Rule 57    boolean -> TRUE
Rule 58    boolean -> FALSE
Rule 59    number -> INTEGER
Rule 60    number -> DOUBLE
Rule 61    arithmeticOperator -> PLUS
Rule 62    arithmeticOperator -> MINUS
Rule 63    arithmeticOperator -> TIMES
Rule 64    arithmeticOperator -> DIVIDE
Rule 65    arithmeticOperator -> MOD
Rule 66    logicOperator -> LOGICAL_AND
Rule 67    logicOperator -> LOGICAL_OR
Rule 68    bitwiseOperator -> BITWISE_AND
Rule 69    bitwiseOperator -> BITWISE_OR
Rule 70    bitwiseOperator -> BITWISE_XOR
Rule 71    comparator -> EQUALS
Rule 72    comparator -> LESS_THAN
Rule 73    comparator -> MORE_THAN
Rule 74    comparator -> LESS_EQUAL
Rule 75    comparator -> MORE_EQUAL
Rule 76    value -> number
Rule 77    value -> MINUS number
Rule 78    value -> object
Rule 79    value -> arithmeticExpression
Rule 80    value -> MINUS LPAREN arithmeticExpression RPAREN
Rule 81    value -> bitwiseExpression
Rule 82    value -> MINUS LPAREN bitwiseExpression RPAREN
Rule 83    value -> logicExpression
Rule 84    value -> NOT LPAREN logicExpression RPAREN
Rule 85    value -> STRING
Rule 86    value -> VARIABLE
Rule 87    value -> NOT VARIABLE
Rule 88    value -> boolean
Rule 89    value -> NOT boolean
Rule 90    value -> variableValuePair
Rule 91    value -> tuple
Rule 92    value -> comparison
Rule 93    value -> NOT LPAREN comparison RPAREN
Rule 94    comparison -> value comparator value
Rule 95    comparison -> LPAREN value comparator value RPAREN
Rule 96    logicExpression -> value logicOperator value
Rule 97    logicExpression -> LPAREN value logicOperator value RPAREN
Rule 98    arithmeticExpression -> value arithmeticOperator value
Rule 99    arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN
Rule 100   bitwiseExpression -> value bitwiseOperator value
Rule 101   bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN
Rule 102   recordTypes -> LPAREN multipleDatatypes RPAREN
Rule 103   recordTypes -> LPAREN parameters RPAREN
Rule 104   recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN
Rule 105   recordTypeAnnotation -> datatype VARIABLE COMMA recordTypeAnnotation
Rule 106   recordTypeAnnotation -> datatype VARIABLE
Rule 107   multipleDatatypes -> datatype COMMA multipleDatatypes
Rule 108   multipleDatatypes -> datatype
Rule 109   variableValuePair -> VARIABLE COLON value
Rule 110   tuple -> LPAREN values RPAREN

Terminals, with rules where they appear

ABSTRACT             : 
ACCEPT_NULL          : 26
AND_ASSIGN           : 39
AS                   : 
ASSERT               : 
ASSIGN               : 31 32
ASYNC                : 
AWAIT                : 
BASE                 : 
BITWISE_AND          : 68
BITWISE_OR           : 69
BITWISE_XOR          : 70
BOOL_TYPE            : 18
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 109
COMMA                : 50 52 105 107
COMMENT              : 
CONST                : 
CONTINUE             : 
COVARIANT            : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 64
DIV_ASSIGN           : 37
DO                   : 
DOLLAR               : 
DOT                  : 48
DOUBLE               : 60
DOUBLE_TYPE          : 16
DYNAMIC              : 
ELSE                 : 
ENUM                 : 
EQUALS               : 71
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 58
FINAL                : 
FINALLY              : 
FOR                  : 
FUNCTION             : 
GET                  : 
HIDE                 : 
IF                   : 8
IF_NULL              : 
IMPLEMENTS           : 
IMPORT               : 9
IN                   : 
INTEGER              : 59
INTERFACE            : 
INT_TYPE             : 15
IS                   : 
LATE                 : 
LBRACE               : 8 49 104
LBRACKET             : 
LESS_EQUAL           : 74
LESS_THAN            : 72
LIBRARY              : 
LIST_TYPE            : 20
LOGICAL_AND          : 66
LOGICAL_OR           : 67
LPAREN               : 8 49 54 55 80 82 84 93 95 97 99 101 102 103 104 110
LSHIFT_ASSIGN        : 42
MAP_TYPE             : 21
MINUS                : 62 77 80 82
MIXIN                : 
MOD                  : 65
MOD_ASSIGN           : 38
MORE_EQUAL           : 75
MORE_THAN            : 73
MULTILINE_COMMENT    : 
MUL_ASSIGN           : 36
NEW                  : 56
NOT                  : 84 87 89 93
NOT_EQUAL            : 
NULL                 : 
NUM_TYPE             : 17
OF                   : 
ON                   : 
OPERATOR             : 
OR_ASSIGN            : 40
PART                 : 
PLUS                 : 61
RBRACE               : 8 49 104
RBRACKET             : 
REQUIRED             : 
RETHROW              : 
RETURN               : 
RPAREN               : 8 49 54 55 80 82 84 93 95 97 99 101 102 103 104 110
RSHIFT_ASSIGN        : 43
RUNES_TYPE           : 23
RUNSIGNED_SHIFT_ASSIGN : 44
SEALED               : 
SEMICOLON            : 1 2
SET                  : 
SET_TYPE             : 22
SHOW                 : 
STATIC               : 
STRING               : 9 85
STRING_TYPE          : 19
SUB_ASSIGN           : 35
SUM_ASSIGN           : 34
SUPER                : 
SWITCH               : 
SYMBOL_TYPE          : 24
SYNC                 : 
THIS                 : 
THROW                : 
TIMES                : 63
TRUE                 : 57
TRY                  : 
TYPE                 : 
TYPEDEF              : 
VARIABLE             : 30 45 46 48 49 50 51 54 55 86 87 105 106 109
VAR_TYPE             : 25
VOID                 : 
WHEN                 : 
WHILE                : 
WITH                 : 
XOR_ASSIGN           : 41
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmeticExpression : 79 80
arithmeticOperator   : 98 99
bitwiseExpression    : 81 82
bitwiseOperator      : 100 101
body                 : 1 3 8 49 0
boolean              : 88 89
comparator           : 94 95
comparison           : 92 93
dataStructure        : 5
datatype             : 30 49 50 51 105 106 107 108
functionCall         : 10 32
functionDeclaration  : 6
if                   : 7
immediateAssign      : 46
import               : 14
instruction          : 1 2
logicExpression      : 83 84
logicOperator        : 96 97
multipleDatatypes    : 102 107
noSemicolonStructure : 3 4
non_nullable_datatype : 26 28
nullable_datatype    : 27
number               : 76 77
object               : 78
parameters           : 49 50 103
prototype            : 47 48 56
recordTypeAnnotation : 104 105
recordTypes          : 29
tuple                : 91
value                : 8 31 46 52 53 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 109
values               : 52 54 110
variableDeclarationInitialized : 12
variableDeclarationUninitialized : 11 33
variableInitialization : 33 45
variableMutation     : 13
variableValuePair    : 90

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . noSemicolonStructure body
    (4) body -> . noSemicolonStructure
    (10) instruction -> . functionCall
    (11) instruction -> . variableDeclarationUninitialized
    (12) instruction -> . variableDeclarationInitialized
    (13) instruction -> . variableMutation
    (14) instruction -> . import
    (5) noSemicolonStructure -> . dataStructure
    (6) noSemicolonStructure -> . functionDeclaration
    (47) functionCall -> . prototype
    (48) functionCall -> . VARIABLE DOT prototype
    (30) variableDeclarationUninitialized -> . datatype VARIABLE
    (33) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (45) variableMutation -> . VARIABLE variableInitialization
    (46) variableMutation -> . VARIABLE immediateAssign value
    (9) import -> . IMPORT STRING
    (7) dataStructure -> . if
    (49) functionDeclaration -> . datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (8) if -> . IF LPAREN value RPAREN LBRACE body RBRACE
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 14
    IF              shift and go to state 20
    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    body                           shift and go to state 1
    instruction                    shift and go to state 2
    noSemicolonStructure           shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    dataStructure                  shift and go to state 9
    functionDeclaration            shift and go to state 10
    prototype                      shift and go to state 11
    datatype                       shift and go to state 13
    if                             shift and go to state 15
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 1

    (0) S' -> body .



state 2

    (1) body -> instruction . SEMICOLON body
    (2) body -> instruction . SEMICOLON

    SEMICOLON       shift and go to state 32


state 3

    (3) body -> noSemicolonStructure . body
    (4) body -> noSemicolonStructure .
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . noSemicolonStructure body
    (4) body -> . noSemicolonStructure
    (10) instruction -> . functionCall
    (11) instruction -> . variableDeclarationUninitialized
    (12) instruction -> . variableDeclarationInitialized
    (13) instruction -> . variableMutation
    (14) instruction -> . import
    (5) noSemicolonStructure -> . dataStructure
    (6) noSemicolonStructure -> . functionDeclaration
    (47) functionCall -> . prototype
    (48) functionCall -> . VARIABLE DOT prototype
    (30) variableDeclarationUninitialized -> . datatype VARIABLE
    (33) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (45) variableMutation -> . VARIABLE variableInitialization
    (46) variableMutation -> . VARIABLE immediateAssign value
    (9) import -> . IMPORT STRING
    (7) dataStructure -> . if
    (49) functionDeclaration -> . datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (8) if -> . IF LPAREN value RPAREN LBRACE body RBRACE
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    $end            reduce using rule 4 (body -> noSemicolonStructure .)
    RBRACE          reduce using rule 4 (body -> noSemicolonStructure .)
    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 14
    IF              shift and go to state 20
    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    noSemicolonStructure           shift and go to state 3
    body                           shift and go to state 33
    instruction                    shift and go to state 2
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    dataStructure                  shift and go to state 9
    functionDeclaration            shift and go to state 10
    prototype                      shift and go to state 11
    datatype                       shift and go to state 13
    if                             shift and go to state 15
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 4

    (10) instruction -> functionCall .

    SEMICOLON       reduce using rule 10 (instruction -> functionCall .)


state 5

    (11) instruction -> variableDeclarationUninitialized .
    (33) variableDeclarationInitialized -> variableDeclarationUninitialized . variableInitialization
    (31) variableInitialization -> . ASSIGN value
    (32) variableInitialization -> . ASSIGN functionCall

    SEMICOLON       reduce using rule 11 (instruction -> variableDeclarationUninitialized .)
    ASSIGN          shift and go to state 35

    variableInitialization         shift and go to state 34

state 6

    (12) instruction -> variableDeclarationInitialized .

    SEMICOLON       reduce using rule 12 (instruction -> variableDeclarationInitialized .)


state 7

    (13) instruction -> variableMutation .

    SEMICOLON       reduce using rule 13 (instruction -> variableMutation .)


state 8

    (14) instruction -> import .

    SEMICOLON       reduce using rule 14 (instruction -> import .)


state 9

    (5) noSemicolonStructure -> dataStructure .

    VARIABLE        reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    IMPORT          reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    IF              reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    INT_TYPE        reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    DOUBLE_TYPE     reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    NUM_TYPE        reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    BOOL_TYPE       reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    STRING_TYPE     reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    LIST_TYPE       reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    MAP_TYPE        reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    SET_TYPE        reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    RUNES_TYPE      reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    SYMBOL_TYPE     reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    VAR_TYPE        reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    LPAREN          reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    $end            reduce using rule 5 (noSemicolonStructure -> dataStructure .)
    RBRACE          reduce using rule 5 (noSemicolonStructure -> dataStructure .)


state 10

    (6) noSemicolonStructure -> functionDeclaration .

    VARIABLE        reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    IMPORT          reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    IF              reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    INT_TYPE        reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    DOUBLE_TYPE     reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    NUM_TYPE        reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    BOOL_TYPE       reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    STRING_TYPE     reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    LIST_TYPE       reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    MAP_TYPE        reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    SET_TYPE        reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    RUNES_TYPE      reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    SYMBOL_TYPE     reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    VAR_TYPE        reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    LPAREN          reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    $end            reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)
    RBRACE          reduce using rule 6 (noSemicolonStructure -> functionDeclaration .)


state 11

    (47) functionCall -> prototype .

    SEMICOLON       reduce using rule 47 (functionCall -> prototype .)


state 12

    (48) functionCall -> VARIABLE . DOT prototype
    (45) variableMutation -> VARIABLE . variableInitialization
    (46) variableMutation -> VARIABLE . immediateAssign value
    (54) prototype -> VARIABLE . LPAREN values RPAREN
    (55) prototype -> VARIABLE . LPAREN RPAREN
    (31) variableInitialization -> . ASSIGN value
    (32) variableInitialization -> . ASSIGN functionCall
    (34) immediateAssign -> . SUM_ASSIGN
    (35) immediateAssign -> . SUB_ASSIGN
    (36) immediateAssign -> . MUL_ASSIGN
    (37) immediateAssign -> . DIV_ASSIGN
    (38) immediateAssign -> . MOD_ASSIGN
    (39) immediateAssign -> . AND_ASSIGN
    (40) immediateAssign -> . OR_ASSIGN
    (41) immediateAssign -> . XOR_ASSIGN
    (42) immediateAssign -> . LSHIFT_ASSIGN
    (43) immediateAssign -> . RSHIFT_ASSIGN
    (44) immediateAssign -> . RUNSIGNED_SHIFT_ASSIGN

    DOT             shift and go to state 36
    LPAREN          shift and go to state 39
    ASSIGN          shift and go to state 35
    SUM_ASSIGN      shift and go to state 40
    SUB_ASSIGN      shift and go to state 41
    MUL_ASSIGN      shift and go to state 42
    DIV_ASSIGN      shift and go to state 43
    MOD_ASSIGN      shift and go to state 44
    AND_ASSIGN      shift and go to state 45
    OR_ASSIGN       shift and go to state 46
    XOR_ASSIGN      shift and go to state 47
    LSHIFT_ASSIGN   shift and go to state 48
    RSHIFT_ASSIGN   shift and go to state 49
    RUNSIGNED_SHIFT_ASSIGN shift and go to state 50

    variableInitialization         shift and go to state 37
    immediateAssign                shift and go to state 38

state 13

    (30) variableDeclarationUninitialized -> datatype . VARIABLE
    (49) functionDeclaration -> datatype . VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE

    VARIABLE        shift and go to state 51


state 14

    (9) import -> IMPORT . STRING

    STRING          shift and go to state 52


state 15

    (7) dataStructure -> if .

    VARIABLE        reduce using rule 7 (dataStructure -> if .)
    IMPORT          reduce using rule 7 (dataStructure -> if .)
    IF              reduce using rule 7 (dataStructure -> if .)
    INT_TYPE        reduce using rule 7 (dataStructure -> if .)
    DOUBLE_TYPE     reduce using rule 7 (dataStructure -> if .)
    NUM_TYPE        reduce using rule 7 (dataStructure -> if .)
    BOOL_TYPE       reduce using rule 7 (dataStructure -> if .)
    STRING_TYPE     reduce using rule 7 (dataStructure -> if .)
    LIST_TYPE       reduce using rule 7 (dataStructure -> if .)
    MAP_TYPE        reduce using rule 7 (dataStructure -> if .)
    SET_TYPE        reduce using rule 7 (dataStructure -> if .)
    RUNES_TYPE      reduce using rule 7 (dataStructure -> if .)
    SYMBOL_TYPE     reduce using rule 7 (dataStructure -> if .)
    VAR_TYPE        reduce using rule 7 (dataStructure -> if .)
    LPAREN          reduce using rule 7 (dataStructure -> if .)
    $end            reduce using rule 7 (dataStructure -> if .)
    RBRACE          reduce using rule 7 (dataStructure -> if .)


state 16

    (102) recordTypes -> LPAREN . multipleDatatypes RPAREN
    (103) recordTypes -> LPAREN . parameters RPAREN
    (104) recordTypes -> LPAREN . LBRACE recordTypeAnnotation RBRACE RPAREN
    (107) multipleDatatypes -> . datatype COMMA multipleDatatypes
    (108) multipleDatatypes -> . datatype
    (50) parameters -> . datatype VARIABLE COMMA parameters
    (51) parameters -> . datatype VARIABLE
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    LBRACE          shift and go to state 55
    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    multipleDatatypes              shift and go to state 53
    parameters                     shift and go to state 54
    datatype                       shift and go to state 56
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 17

    (27) datatype -> nullable_datatype .

    VARIABLE        reduce using rule 27 (datatype -> nullable_datatype .)
    COMMA           reduce using rule 27 (datatype -> nullable_datatype .)
    RPAREN          reduce using rule 27 (datatype -> nullable_datatype .)


state 18

    (28) datatype -> non_nullable_datatype .
    (26) nullable_datatype -> non_nullable_datatype . ACCEPT_NULL

    VARIABLE        reduce using rule 28 (datatype -> non_nullable_datatype .)
    COMMA           reduce using rule 28 (datatype -> non_nullable_datatype .)
    RPAREN          reduce using rule 28 (datatype -> non_nullable_datatype .)
    ACCEPT_NULL     shift and go to state 57


state 19

    (29) datatype -> recordTypes .

    VARIABLE        reduce using rule 29 (datatype -> recordTypes .)
    COMMA           reduce using rule 29 (datatype -> recordTypes .)
    RPAREN          reduce using rule 29 (datatype -> recordTypes .)


state 20

    (8) if -> IF . LPAREN value RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 58


state 21

    (15) non_nullable_datatype -> INT_TYPE .

    ACCEPT_NULL     reduce using rule 15 (non_nullable_datatype -> INT_TYPE .)
    VARIABLE        reduce using rule 15 (non_nullable_datatype -> INT_TYPE .)
    COMMA           reduce using rule 15 (non_nullable_datatype -> INT_TYPE .)
    RPAREN          reduce using rule 15 (non_nullable_datatype -> INT_TYPE .)


state 22

    (16) non_nullable_datatype -> DOUBLE_TYPE .

    ACCEPT_NULL     reduce using rule 16 (non_nullable_datatype -> DOUBLE_TYPE .)
    VARIABLE        reduce using rule 16 (non_nullable_datatype -> DOUBLE_TYPE .)
    COMMA           reduce using rule 16 (non_nullable_datatype -> DOUBLE_TYPE .)
    RPAREN          reduce using rule 16 (non_nullable_datatype -> DOUBLE_TYPE .)


state 23

    (17) non_nullable_datatype -> NUM_TYPE .

    ACCEPT_NULL     reduce using rule 17 (non_nullable_datatype -> NUM_TYPE .)
    VARIABLE        reduce using rule 17 (non_nullable_datatype -> NUM_TYPE .)
    COMMA           reduce using rule 17 (non_nullable_datatype -> NUM_TYPE .)
    RPAREN          reduce using rule 17 (non_nullable_datatype -> NUM_TYPE .)


state 24

    (18) non_nullable_datatype -> BOOL_TYPE .

    ACCEPT_NULL     reduce using rule 18 (non_nullable_datatype -> BOOL_TYPE .)
    VARIABLE        reduce using rule 18 (non_nullable_datatype -> BOOL_TYPE .)
    COMMA           reduce using rule 18 (non_nullable_datatype -> BOOL_TYPE .)
    RPAREN          reduce using rule 18 (non_nullable_datatype -> BOOL_TYPE .)


state 25

    (19) non_nullable_datatype -> STRING_TYPE .

    ACCEPT_NULL     reduce using rule 19 (non_nullable_datatype -> STRING_TYPE .)
    VARIABLE        reduce using rule 19 (non_nullable_datatype -> STRING_TYPE .)
    COMMA           reduce using rule 19 (non_nullable_datatype -> STRING_TYPE .)
    RPAREN          reduce using rule 19 (non_nullable_datatype -> STRING_TYPE .)


state 26

    (20) non_nullable_datatype -> LIST_TYPE .

    ACCEPT_NULL     reduce using rule 20 (non_nullable_datatype -> LIST_TYPE .)
    VARIABLE        reduce using rule 20 (non_nullable_datatype -> LIST_TYPE .)
    COMMA           reduce using rule 20 (non_nullable_datatype -> LIST_TYPE .)
    RPAREN          reduce using rule 20 (non_nullable_datatype -> LIST_TYPE .)


state 27

    (21) non_nullable_datatype -> MAP_TYPE .

    ACCEPT_NULL     reduce using rule 21 (non_nullable_datatype -> MAP_TYPE .)
    VARIABLE        reduce using rule 21 (non_nullable_datatype -> MAP_TYPE .)
    COMMA           reduce using rule 21 (non_nullable_datatype -> MAP_TYPE .)
    RPAREN          reduce using rule 21 (non_nullable_datatype -> MAP_TYPE .)


state 28

    (22) non_nullable_datatype -> SET_TYPE .

    ACCEPT_NULL     reduce using rule 22 (non_nullable_datatype -> SET_TYPE .)
    VARIABLE        reduce using rule 22 (non_nullable_datatype -> SET_TYPE .)
    COMMA           reduce using rule 22 (non_nullable_datatype -> SET_TYPE .)
    RPAREN          reduce using rule 22 (non_nullable_datatype -> SET_TYPE .)


state 29

    (23) non_nullable_datatype -> RUNES_TYPE .

    ACCEPT_NULL     reduce using rule 23 (non_nullable_datatype -> RUNES_TYPE .)
    VARIABLE        reduce using rule 23 (non_nullable_datatype -> RUNES_TYPE .)
    COMMA           reduce using rule 23 (non_nullable_datatype -> RUNES_TYPE .)
    RPAREN          reduce using rule 23 (non_nullable_datatype -> RUNES_TYPE .)


state 30

    (24) non_nullable_datatype -> SYMBOL_TYPE .

    ACCEPT_NULL     reduce using rule 24 (non_nullable_datatype -> SYMBOL_TYPE .)
    VARIABLE        reduce using rule 24 (non_nullable_datatype -> SYMBOL_TYPE .)
    COMMA           reduce using rule 24 (non_nullable_datatype -> SYMBOL_TYPE .)
    RPAREN          reduce using rule 24 (non_nullable_datatype -> SYMBOL_TYPE .)


state 31

    (25) non_nullable_datatype -> VAR_TYPE .

    ACCEPT_NULL     reduce using rule 25 (non_nullable_datatype -> VAR_TYPE .)
    VARIABLE        reduce using rule 25 (non_nullable_datatype -> VAR_TYPE .)
    COMMA           reduce using rule 25 (non_nullable_datatype -> VAR_TYPE .)
    RPAREN          reduce using rule 25 (non_nullable_datatype -> VAR_TYPE .)


state 32

    (1) body -> instruction SEMICOLON . body
    (2) body -> instruction SEMICOLON .
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . noSemicolonStructure body
    (4) body -> . noSemicolonStructure
    (10) instruction -> . functionCall
    (11) instruction -> . variableDeclarationUninitialized
    (12) instruction -> . variableDeclarationInitialized
    (13) instruction -> . variableMutation
    (14) instruction -> . import
    (5) noSemicolonStructure -> . dataStructure
    (6) noSemicolonStructure -> . functionDeclaration
    (47) functionCall -> . prototype
    (48) functionCall -> . VARIABLE DOT prototype
    (30) variableDeclarationUninitialized -> . datatype VARIABLE
    (33) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (45) variableMutation -> . VARIABLE variableInitialization
    (46) variableMutation -> . VARIABLE immediateAssign value
    (9) import -> . IMPORT STRING
    (7) dataStructure -> . if
    (49) functionDeclaration -> . datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (8) if -> . IF LPAREN value RPAREN LBRACE body RBRACE
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    $end            reduce using rule 2 (body -> instruction SEMICOLON .)
    RBRACE          reduce using rule 2 (body -> instruction SEMICOLON .)
    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 14
    IF              shift and go to state 20
    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    instruction                    shift and go to state 2
    body                           shift and go to state 59
    noSemicolonStructure           shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    dataStructure                  shift and go to state 9
    functionDeclaration            shift and go to state 10
    prototype                      shift and go to state 11
    datatype                       shift and go to state 13
    if                             shift and go to state 15
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 33

    (3) body -> noSemicolonStructure body .

    $end            reduce using rule 3 (body -> noSemicolonStructure body .)
    RBRACE          reduce using rule 3 (body -> noSemicolonStructure body .)


state 34

    (33) variableDeclarationInitialized -> variableDeclarationUninitialized variableInitialization .

    SEMICOLON       reduce using rule 33 (variableDeclarationInitialized -> variableDeclarationUninitialized variableInitialization .)


state 35

    (31) variableInitialization -> ASSIGN . value
    (32) variableInitialization -> ASSIGN . functionCall
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (47) functionCall -> . prototype
    (48) functionCall -> . VARIABLE DOT prototype
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 71
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 60
    functionCall                   shift and go to state 61
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75
    prototype                      shift and go to state 11

state 36

    (48) functionCall -> VARIABLE DOT . prototype
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 81

    prototype                      shift and go to state 82

state 37

    (45) variableMutation -> VARIABLE variableInitialization .

    SEMICOLON       reduce using rule 45 (variableMutation -> VARIABLE variableInitialization .)


state 38

    (46) variableMutation -> VARIABLE immediateAssign . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 84
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 39

    (54) prototype -> VARIABLE LPAREN . values RPAREN
    (55) prototype -> VARIABLE LPAREN . RPAREN
    (52) values -> . value COMMA values
    (53) values -> . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    RPAREN          shift and go to state 86
    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    values                         shift and go to state 85
    value                          shift and go to state 87
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 40

    (34) immediateAssign -> SUM_ASSIGN .

    MINUS           reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    NOT             reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    STRING          reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    VARIABLE        reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    INTEGER         reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    DOUBLE          reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    NEW             reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    LPAREN          reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    TRUE            reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)
    FALSE           reduce using rule 34 (immediateAssign -> SUM_ASSIGN .)


state 41

    (35) immediateAssign -> SUB_ASSIGN .

    MINUS           reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    NOT             reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    STRING          reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    VARIABLE        reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    INTEGER         reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    DOUBLE          reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    NEW             reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    LPAREN          reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    TRUE            reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)
    FALSE           reduce using rule 35 (immediateAssign -> SUB_ASSIGN .)


state 42

    (36) immediateAssign -> MUL_ASSIGN .

    MINUS           reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    NOT             reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    STRING          reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    VARIABLE        reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    INTEGER         reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    DOUBLE          reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    NEW             reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    LPAREN          reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    TRUE            reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)
    FALSE           reduce using rule 36 (immediateAssign -> MUL_ASSIGN .)


state 43

    (37) immediateAssign -> DIV_ASSIGN .

    MINUS           reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    NOT             reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    STRING          reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    VARIABLE        reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    INTEGER         reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    DOUBLE          reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    NEW             reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    LPAREN          reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    TRUE            reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)
    FALSE           reduce using rule 37 (immediateAssign -> DIV_ASSIGN .)


state 44

    (38) immediateAssign -> MOD_ASSIGN .

    MINUS           reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    NOT             reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    STRING          reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    VARIABLE        reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    INTEGER         reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    DOUBLE          reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    NEW             reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    LPAREN          reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    TRUE            reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)
    FALSE           reduce using rule 38 (immediateAssign -> MOD_ASSIGN .)


state 45

    (39) immediateAssign -> AND_ASSIGN .

    MINUS           reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    NOT             reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    STRING          reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    VARIABLE        reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    INTEGER         reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    DOUBLE          reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    NEW             reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    LPAREN          reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    TRUE            reduce using rule 39 (immediateAssign -> AND_ASSIGN .)
    FALSE           reduce using rule 39 (immediateAssign -> AND_ASSIGN .)


state 46

    (40) immediateAssign -> OR_ASSIGN .

    MINUS           reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    NOT             reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    STRING          reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    VARIABLE        reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    INTEGER         reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    DOUBLE          reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    NEW             reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    LPAREN          reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    TRUE            reduce using rule 40 (immediateAssign -> OR_ASSIGN .)
    FALSE           reduce using rule 40 (immediateAssign -> OR_ASSIGN .)


state 47

    (41) immediateAssign -> XOR_ASSIGN .

    MINUS           reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    NOT             reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    STRING          reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    VARIABLE        reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    INTEGER         reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    DOUBLE          reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    NEW             reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    LPAREN          reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    TRUE            reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)
    FALSE           reduce using rule 41 (immediateAssign -> XOR_ASSIGN .)


state 48

    (42) immediateAssign -> LSHIFT_ASSIGN .

    MINUS           reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    NOT             reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    VARIABLE        reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    INTEGER         reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    DOUBLE          reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    NEW             reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    LPAREN          reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    TRUE            reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)
    FALSE           reduce using rule 42 (immediateAssign -> LSHIFT_ASSIGN .)


state 49

    (43) immediateAssign -> RSHIFT_ASSIGN .

    MINUS           reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    NOT             reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    VARIABLE        reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    INTEGER         reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    DOUBLE          reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    NEW             reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    LPAREN          reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    TRUE            reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)
    FALSE           reduce using rule 43 (immediateAssign -> RSHIFT_ASSIGN .)


state 50

    (44) immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .

    MINUS           reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    NOT             reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    STRING          reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    VARIABLE        reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    INTEGER         reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    DOUBLE          reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    NEW             reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    LPAREN          reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    TRUE            reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)
    FALSE           reduce using rule 44 (immediateAssign -> RUNSIGNED_SHIFT_ASSIGN .)


state 51

    (30) variableDeclarationUninitialized -> datatype VARIABLE .
    (49) functionDeclaration -> datatype VARIABLE . LPAREN parameters RPAREN LBRACE body RBRACE

    ASSIGN          reduce using rule 30 (variableDeclarationUninitialized -> datatype VARIABLE .)
    SEMICOLON       reduce using rule 30 (variableDeclarationUninitialized -> datatype VARIABLE .)
    LPAREN          shift and go to state 88


state 52

    (9) import -> IMPORT STRING .

    SEMICOLON       reduce using rule 9 (import -> IMPORT STRING .)


state 53

    (102) recordTypes -> LPAREN multipleDatatypes . RPAREN

    RPAREN          shift and go to state 89


state 54

    (103) recordTypes -> LPAREN parameters . RPAREN

    RPAREN          shift and go to state 90


state 55

    (104) recordTypes -> LPAREN LBRACE . recordTypeAnnotation RBRACE RPAREN
    (105) recordTypeAnnotation -> . datatype VARIABLE COMMA recordTypeAnnotation
    (106) recordTypeAnnotation -> . datatype VARIABLE
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    recordTypeAnnotation           shift and go to state 91
    datatype                       shift and go to state 92
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 56

    (107) multipleDatatypes -> datatype . COMMA multipleDatatypes
    (108) multipleDatatypes -> datatype .
    (50) parameters -> datatype . VARIABLE COMMA parameters
    (51) parameters -> datatype . VARIABLE

    COMMA           shift and go to state 93
    RPAREN          reduce using rule 108 (multipleDatatypes -> datatype .)
    VARIABLE        shift and go to state 94


state 57

    (26) nullable_datatype -> non_nullable_datatype ACCEPT_NULL .

    VARIABLE        reduce using rule 26 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)
    COMMA           reduce using rule 26 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)
    RPAREN          reduce using rule 26 (nullable_datatype -> non_nullable_datatype ACCEPT_NULL .)


state 58

    (8) if -> IF LPAREN . value RPAREN LBRACE body RBRACE
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 95
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 59

    (1) body -> instruction SEMICOLON body .

    $end            reduce using rule 1 (body -> instruction SEMICOLON body .)
    RBRACE          reduce using rule 1 (body -> instruction SEMICOLON body .)


state 60

    (31) variableInitialization -> ASSIGN value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

    SEMICOLON       reduce using rule 31 (variableInitialization -> ASSIGN value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 61

    (32) variableInitialization -> ASSIGN functionCall .

    SEMICOLON       reduce using rule 32 (variableInitialization -> ASSIGN functionCall .)


state 62

    (76) value -> number .

    PLUS            reduce using rule 76 (value -> number .)
    MINUS           reduce using rule 76 (value -> number .)
    TIMES           reduce using rule 76 (value -> number .)
    DIVIDE          reduce using rule 76 (value -> number .)
    MOD             reduce using rule 76 (value -> number .)
    BITWISE_AND     reduce using rule 76 (value -> number .)
    BITWISE_OR      reduce using rule 76 (value -> number .)
    BITWISE_XOR     reduce using rule 76 (value -> number .)
    LOGICAL_AND     reduce using rule 76 (value -> number .)
    LOGICAL_OR      reduce using rule 76 (value -> number .)
    EQUALS          reduce using rule 76 (value -> number .)
    LESS_THAN       reduce using rule 76 (value -> number .)
    MORE_THAN       reduce using rule 76 (value -> number .)
    LESS_EQUAL      reduce using rule 76 (value -> number .)
    MORE_EQUAL      reduce using rule 76 (value -> number .)
    SEMICOLON       reduce using rule 76 (value -> number .)
    COMMA           reduce using rule 76 (value -> number .)
    RPAREN          reduce using rule 76 (value -> number .)


state 63

    (77) value -> MINUS . number
    (80) value -> MINUS . LPAREN arithmeticExpression RPAREN
    (82) value -> MINUS . LPAREN bitwiseExpression RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE

    LPAREN          shift and go to state 116
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77

    number                         shift and go to state 115

state 64

    (78) value -> object .

    PLUS            reduce using rule 78 (value -> object .)
    MINUS           reduce using rule 78 (value -> object .)
    TIMES           reduce using rule 78 (value -> object .)
    DIVIDE          reduce using rule 78 (value -> object .)
    MOD             reduce using rule 78 (value -> object .)
    BITWISE_AND     reduce using rule 78 (value -> object .)
    BITWISE_OR      reduce using rule 78 (value -> object .)
    BITWISE_XOR     reduce using rule 78 (value -> object .)
    LOGICAL_AND     reduce using rule 78 (value -> object .)
    LOGICAL_OR      reduce using rule 78 (value -> object .)
    EQUALS          reduce using rule 78 (value -> object .)
    LESS_THAN       reduce using rule 78 (value -> object .)
    MORE_THAN       reduce using rule 78 (value -> object .)
    LESS_EQUAL      reduce using rule 78 (value -> object .)
    MORE_EQUAL      reduce using rule 78 (value -> object .)
    SEMICOLON       reduce using rule 78 (value -> object .)
    COMMA           reduce using rule 78 (value -> object .)
    RPAREN          reduce using rule 78 (value -> object .)


state 65

    (79) value -> arithmeticExpression .

    PLUS            reduce using rule 79 (value -> arithmeticExpression .)
    MINUS           reduce using rule 79 (value -> arithmeticExpression .)
    TIMES           reduce using rule 79 (value -> arithmeticExpression .)
    DIVIDE          reduce using rule 79 (value -> arithmeticExpression .)
    MOD             reduce using rule 79 (value -> arithmeticExpression .)
    BITWISE_AND     reduce using rule 79 (value -> arithmeticExpression .)
    BITWISE_OR      reduce using rule 79 (value -> arithmeticExpression .)
    BITWISE_XOR     reduce using rule 79 (value -> arithmeticExpression .)
    LOGICAL_AND     reduce using rule 79 (value -> arithmeticExpression .)
    LOGICAL_OR      reduce using rule 79 (value -> arithmeticExpression .)
    EQUALS          reduce using rule 79 (value -> arithmeticExpression .)
    LESS_THAN       reduce using rule 79 (value -> arithmeticExpression .)
    MORE_THAN       reduce using rule 79 (value -> arithmeticExpression .)
    LESS_EQUAL      reduce using rule 79 (value -> arithmeticExpression .)
    MORE_EQUAL      reduce using rule 79 (value -> arithmeticExpression .)
    SEMICOLON       reduce using rule 79 (value -> arithmeticExpression .)
    COMMA           reduce using rule 79 (value -> arithmeticExpression .)
    RPAREN          reduce using rule 79 (value -> arithmeticExpression .)


state 66

    (99) arithmeticExpression -> LPAREN . value arithmeticOperator value RPAREN
    (101) bitwiseExpression -> LPAREN . value bitwiseOperator value RPAREN
    (97) logicExpression -> LPAREN . value logicOperator value RPAREN
    (110) tuple -> LPAREN . values RPAREN
    (95) comparison -> LPAREN . value comparator value RPAREN
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (52) values -> . value COMMA values
    (53) values -> . value
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 117
    values                         shift and go to state 118
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 67

    (81) value -> bitwiseExpression .

    PLUS            reduce using rule 81 (value -> bitwiseExpression .)
    MINUS           reduce using rule 81 (value -> bitwiseExpression .)
    TIMES           reduce using rule 81 (value -> bitwiseExpression .)
    DIVIDE          reduce using rule 81 (value -> bitwiseExpression .)
    MOD             reduce using rule 81 (value -> bitwiseExpression .)
    BITWISE_AND     reduce using rule 81 (value -> bitwiseExpression .)
    BITWISE_OR      reduce using rule 81 (value -> bitwiseExpression .)
    BITWISE_XOR     reduce using rule 81 (value -> bitwiseExpression .)
    LOGICAL_AND     reduce using rule 81 (value -> bitwiseExpression .)
    LOGICAL_OR      reduce using rule 81 (value -> bitwiseExpression .)
    EQUALS          reduce using rule 81 (value -> bitwiseExpression .)
    LESS_THAN       reduce using rule 81 (value -> bitwiseExpression .)
    MORE_THAN       reduce using rule 81 (value -> bitwiseExpression .)
    LESS_EQUAL      reduce using rule 81 (value -> bitwiseExpression .)
    MORE_EQUAL      reduce using rule 81 (value -> bitwiseExpression .)
    SEMICOLON       reduce using rule 81 (value -> bitwiseExpression .)
    COMMA           reduce using rule 81 (value -> bitwiseExpression .)
    RPAREN          reduce using rule 81 (value -> bitwiseExpression .)


state 68

    (83) value -> logicExpression .

    PLUS            reduce using rule 83 (value -> logicExpression .)
    MINUS           reduce using rule 83 (value -> logicExpression .)
    TIMES           reduce using rule 83 (value -> logicExpression .)
    DIVIDE          reduce using rule 83 (value -> logicExpression .)
    MOD             reduce using rule 83 (value -> logicExpression .)
    BITWISE_AND     reduce using rule 83 (value -> logicExpression .)
    BITWISE_OR      reduce using rule 83 (value -> logicExpression .)
    BITWISE_XOR     reduce using rule 83 (value -> logicExpression .)
    LOGICAL_AND     reduce using rule 83 (value -> logicExpression .)
    LOGICAL_OR      reduce using rule 83 (value -> logicExpression .)
    EQUALS          reduce using rule 83 (value -> logicExpression .)
    LESS_THAN       reduce using rule 83 (value -> logicExpression .)
    MORE_THAN       reduce using rule 83 (value -> logicExpression .)
    LESS_EQUAL      reduce using rule 83 (value -> logicExpression .)
    MORE_EQUAL      reduce using rule 83 (value -> logicExpression .)
    SEMICOLON       reduce using rule 83 (value -> logicExpression .)
    COMMA           reduce using rule 83 (value -> logicExpression .)
    RPAREN          reduce using rule 83 (value -> logicExpression .)


state 69

    (84) value -> NOT . LPAREN logicExpression RPAREN
    (87) value -> NOT . VARIABLE
    (89) value -> NOT . boolean
    (93) value -> NOT . LPAREN comparison RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE

    LPAREN          shift and go to state 119
    VARIABLE        shift and go to state 120
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    boolean                        shift and go to state 121

state 70

    (85) value -> STRING .

    PLUS            reduce using rule 85 (value -> STRING .)
    MINUS           reduce using rule 85 (value -> STRING .)
    TIMES           reduce using rule 85 (value -> STRING .)
    DIVIDE          reduce using rule 85 (value -> STRING .)
    MOD             reduce using rule 85 (value -> STRING .)
    BITWISE_AND     reduce using rule 85 (value -> STRING .)
    BITWISE_OR      reduce using rule 85 (value -> STRING .)
    BITWISE_XOR     reduce using rule 85 (value -> STRING .)
    LOGICAL_AND     reduce using rule 85 (value -> STRING .)
    LOGICAL_OR      reduce using rule 85 (value -> STRING .)
    EQUALS          reduce using rule 85 (value -> STRING .)
    LESS_THAN       reduce using rule 85 (value -> STRING .)
    MORE_THAN       reduce using rule 85 (value -> STRING .)
    LESS_EQUAL      reduce using rule 85 (value -> STRING .)
    MORE_EQUAL      reduce using rule 85 (value -> STRING .)
    SEMICOLON       reduce using rule 85 (value -> STRING .)
    COMMA           reduce using rule 85 (value -> STRING .)
    RPAREN          reduce using rule 85 (value -> STRING .)


state 71

    (86) value -> VARIABLE .
    (48) functionCall -> VARIABLE . DOT prototype
    (109) variableValuePair -> VARIABLE . COLON value
    (54) prototype -> VARIABLE . LPAREN values RPAREN
    (55) prototype -> VARIABLE . LPAREN RPAREN

    PLUS            reduce using rule 86 (value -> VARIABLE .)
    MINUS           reduce using rule 86 (value -> VARIABLE .)
    TIMES           reduce using rule 86 (value -> VARIABLE .)
    DIVIDE          reduce using rule 86 (value -> VARIABLE .)
    MOD             reduce using rule 86 (value -> VARIABLE .)
    BITWISE_AND     reduce using rule 86 (value -> VARIABLE .)
    BITWISE_OR      reduce using rule 86 (value -> VARIABLE .)
    BITWISE_XOR     reduce using rule 86 (value -> VARIABLE .)
    LOGICAL_AND     reduce using rule 86 (value -> VARIABLE .)
    LOGICAL_OR      reduce using rule 86 (value -> VARIABLE .)
    EQUALS          reduce using rule 86 (value -> VARIABLE .)
    LESS_THAN       reduce using rule 86 (value -> VARIABLE .)
    MORE_THAN       reduce using rule 86 (value -> VARIABLE .)
    LESS_EQUAL      reduce using rule 86 (value -> VARIABLE .)
    MORE_EQUAL      reduce using rule 86 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 86 (value -> VARIABLE .)
    DOT             shift and go to state 36
    COLON           shift and go to state 122
    LPAREN          shift and go to state 39


state 72

    (88) value -> boolean .

    PLUS            reduce using rule 88 (value -> boolean .)
    MINUS           reduce using rule 88 (value -> boolean .)
    TIMES           reduce using rule 88 (value -> boolean .)
    DIVIDE          reduce using rule 88 (value -> boolean .)
    MOD             reduce using rule 88 (value -> boolean .)
    BITWISE_AND     reduce using rule 88 (value -> boolean .)
    BITWISE_OR      reduce using rule 88 (value -> boolean .)
    BITWISE_XOR     reduce using rule 88 (value -> boolean .)
    LOGICAL_AND     reduce using rule 88 (value -> boolean .)
    LOGICAL_OR      reduce using rule 88 (value -> boolean .)
    EQUALS          reduce using rule 88 (value -> boolean .)
    LESS_THAN       reduce using rule 88 (value -> boolean .)
    MORE_THAN       reduce using rule 88 (value -> boolean .)
    LESS_EQUAL      reduce using rule 88 (value -> boolean .)
    MORE_EQUAL      reduce using rule 88 (value -> boolean .)
    SEMICOLON       reduce using rule 88 (value -> boolean .)
    COMMA           reduce using rule 88 (value -> boolean .)
    RPAREN          reduce using rule 88 (value -> boolean .)


state 73

    (90) value -> variableValuePair .

    PLUS            reduce using rule 90 (value -> variableValuePair .)
    MINUS           reduce using rule 90 (value -> variableValuePair .)
    TIMES           reduce using rule 90 (value -> variableValuePair .)
    DIVIDE          reduce using rule 90 (value -> variableValuePair .)
    MOD             reduce using rule 90 (value -> variableValuePair .)
    BITWISE_AND     reduce using rule 90 (value -> variableValuePair .)
    BITWISE_OR      reduce using rule 90 (value -> variableValuePair .)
    BITWISE_XOR     reduce using rule 90 (value -> variableValuePair .)
    LOGICAL_AND     reduce using rule 90 (value -> variableValuePair .)
    LOGICAL_OR      reduce using rule 90 (value -> variableValuePair .)
    EQUALS          reduce using rule 90 (value -> variableValuePair .)
    LESS_THAN       reduce using rule 90 (value -> variableValuePair .)
    MORE_THAN       reduce using rule 90 (value -> variableValuePair .)
    LESS_EQUAL      reduce using rule 90 (value -> variableValuePair .)
    MORE_EQUAL      reduce using rule 90 (value -> variableValuePair .)
    SEMICOLON       reduce using rule 90 (value -> variableValuePair .)
    COMMA           reduce using rule 90 (value -> variableValuePair .)
    RPAREN          reduce using rule 90 (value -> variableValuePair .)


state 74

    (91) value -> tuple .

    PLUS            reduce using rule 91 (value -> tuple .)
    MINUS           reduce using rule 91 (value -> tuple .)
    TIMES           reduce using rule 91 (value -> tuple .)
    DIVIDE          reduce using rule 91 (value -> tuple .)
    MOD             reduce using rule 91 (value -> tuple .)
    BITWISE_AND     reduce using rule 91 (value -> tuple .)
    BITWISE_OR      reduce using rule 91 (value -> tuple .)
    BITWISE_XOR     reduce using rule 91 (value -> tuple .)
    LOGICAL_AND     reduce using rule 91 (value -> tuple .)
    LOGICAL_OR      reduce using rule 91 (value -> tuple .)
    EQUALS          reduce using rule 91 (value -> tuple .)
    LESS_THAN       reduce using rule 91 (value -> tuple .)
    MORE_THAN       reduce using rule 91 (value -> tuple .)
    LESS_EQUAL      reduce using rule 91 (value -> tuple .)
    MORE_EQUAL      reduce using rule 91 (value -> tuple .)
    SEMICOLON       reduce using rule 91 (value -> tuple .)
    COMMA           reduce using rule 91 (value -> tuple .)
    RPAREN          reduce using rule 91 (value -> tuple .)


state 75

    (92) value -> comparison .

    PLUS            reduce using rule 92 (value -> comparison .)
    MINUS           reduce using rule 92 (value -> comparison .)
    TIMES           reduce using rule 92 (value -> comparison .)
    DIVIDE          reduce using rule 92 (value -> comparison .)
    MOD             reduce using rule 92 (value -> comparison .)
    BITWISE_AND     reduce using rule 92 (value -> comparison .)
    BITWISE_OR      reduce using rule 92 (value -> comparison .)
    BITWISE_XOR     reduce using rule 92 (value -> comparison .)
    LOGICAL_AND     reduce using rule 92 (value -> comparison .)
    LOGICAL_OR      reduce using rule 92 (value -> comparison .)
    EQUALS          reduce using rule 92 (value -> comparison .)
    LESS_THAN       reduce using rule 92 (value -> comparison .)
    MORE_THAN       reduce using rule 92 (value -> comparison .)
    LESS_EQUAL      reduce using rule 92 (value -> comparison .)
    MORE_EQUAL      reduce using rule 92 (value -> comparison .)
    SEMICOLON       reduce using rule 92 (value -> comparison .)
    COMMA           reduce using rule 92 (value -> comparison .)
    RPAREN          reduce using rule 92 (value -> comparison .)


state 76

    (59) number -> INTEGER .

    PLUS            reduce using rule 59 (number -> INTEGER .)
    MINUS           reduce using rule 59 (number -> INTEGER .)
    TIMES           reduce using rule 59 (number -> INTEGER .)
    DIVIDE          reduce using rule 59 (number -> INTEGER .)
    MOD             reduce using rule 59 (number -> INTEGER .)
    BITWISE_AND     reduce using rule 59 (number -> INTEGER .)
    BITWISE_OR      reduce using rule 59 (number -> INTEGER .)
    BITWISE_XOR     reduce using rule 59 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 59 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 59 (number -> INTEGER .)
    EQUALS          reduce using rule 59 (number -> INTEGER .)
    LESS_THAN       reduce using rule 59 (number -> INTEGER .)
    MORE_THAN       reduce using rule 59 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 59 (number -> INTEGER .)
    MORE_EQUAL      reduce using rule 59 (number -> INTEGER .)
    SEMICOLON       reduce using rule 59 (number -> INTEGER .)
    COMMA           reduce using rule 59 (number -> INTEGER .)
    RPAREN          reduce using rule 59 (number -> INTEGER .)


state 77

    (60) number -> DOUBLE .

    PLUS            reduce using rule 60 (number -> DOUBLE .)
    MINUS           reduce using rule 60 (number -> DOUBLE .)
    TIMES           reduce using rule 60 (number -> DOUBLE .)
    DIVIDE          reduce using rule 60 (number -> DOUBLE .)
    MOD             reduce using rule 60 (number -> DOUBLE .)
    BITWISE_AND     reduce using rule 60 (number -> DOUBLE .)
    BITWISE_OR      reduce using rule 60 (number -> DOUBLE .)
    BITWISE_XOR     reduce using rule 60 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 60 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 60 (number -> DOUBLE .)
    EQUALS          reduce using rule 60 (number -> DOUBLE .)
    LESS_THAN       reduce using rule 60 (number -> DOUBLE .)
    MORE_THAN       reduce using rule 60 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 60 (number -> DOUBLE .)
    MORE_EQUAL      reduce using rule 60 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 60 (number -> DOUBLE .)
    COMMA           reduce using rule 60 (number -> DOUBLE .)
    RPAREN          reduce using rule 60 (number -> DOUBLE .)


state 78

    (56) object -> NEW . prototype
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 81

    prototype                      shift and go to state 123

state 79

    (57) boolean -> TRUE .

    PLUS            reduce using rule 57 (boolean -> TRUE .)
    MINUS           reduce using rule 57 (boolean -> TRUE .)
    TIMES           reduce using rule 57 (boolean -> TRUE .)
    DIVIDE          reduce using rule 57 (boolean -> TRUE .)
    MOD             reduce using rule 57 (boolean -> TRUE .)
    BITWISE_AND     reduce using rule 57 (boolean -> TRUE .)
    BITWISE_OR      reduce using rule 57 (boolean -> TRUE .)
    BITWISE_XOR     reduce using rule 57 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 57 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 57 (boolean -> TRUE .)
    EQUALS          reduce using rule 57 (boolean -> TRUE .)
    LESS_THAN       reduce using rule 57 (boolean -> TRUE .)
    MORE_THAN       reduce using rule 57 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 57 (boolean -> TRUE .)
    MORE_EQUAL      reduce using rule 57 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 57 (boolean -> TRUE .)
    COMMA           reduce using rule 57 (boolean -> TRUE .)
    RPAREN          reduce using rule 57 (boolean -> TRUE .)


state 80

    (58) boolean -> FALSE .

    PLUS            reduce using rule 58 (boolean -> FALSE .)
    MINUS           reduce using rule 58 (boolean -> FALSE .)
    TIMES           reduce using rule 58 (boolean -> FALSE .)
    DIVIDE          reduce using rule 58 (boolean -> FALSE .)
    MOD             reduce using rule 58 (boolean -> FALSE .)
    BITWISE_AND     reduce using rule 58 (boolean -> FALSE .)
    BITWISE_OR      reduce using rule 58 (boolean -> FALSE .)
    BITWISE_XOR     reduce using rule 58 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 58 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 58 (boolean -> FALSE .)
    EQUALS          reduce using rule 58 (boolean -> FALSE .)
    LESS_THAN       reduce using rule 58 (boolean -> FALSE .)
    MORE_THAN       reduce using rule 58 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 58 (boolean -> FALSE .)
    MORE_EQUAL      reduce using rule 58 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 58 (boolean -> FALSE .)
    COMMA           reduce using rule 58 (boolean -> FALSE .)
    RPAREN          reduce using rule 58 (boolean -> FALSE .)


state 81

    (54) prototype -> VARIABLE . LPAREN values RPAREN
    (55) prototype -> VARIABLE . LPAREN RPAREN

    LPAREN          shift and go to state 39


state 82

    (48) functionCall -> VARIABLE DOT prototype .

    SEMICOLON       reduce using rule 48 (functionCall -> VARIABLE DOT prototype .)


state 83

    (86) value -> VARIABLE .
    (109) variableValuePair -> VARIABLE . COLON value

    PLUS            reduce using rule 86 (value -> VARIABLE .)
    MINUS           reduce using rule 86 (value -> VARIABLE .)
    TIMES           reduce using rule 86 (value -> VARIABLE .)
    DIVIDE          reduce using rule 86 (value -> VARIABLE .)
    MOD             reduce using rule 86 (value -> VARIABLE .)
    BITWISE_AND     reduce using rule 86 (value -> VARIABLE .)
    BITWISE_OR      reduce using rule 86 (value -> VARIABLE .)
    BITWISE_XOR     reduce using rule 86 (value -> VARIABLE .)
    LOGICAL_AND     reduce using rule 86 (value -> VARIABLE .)
    LOGICAL_OR      reduce using rule 86 (value -> VARIABLE .)
    EQUALS          reduce using rule 86 (value -> VARIABLE .)
    LESS_THAN       reduce using rule 86 (value -> VARIABLE .)
    MORE_THAN       reduce using rule 86 (value -> VARIABLE .)
    LESS_EQUAL      reduce using rule 86 (value -> VARIABLE .)
    MORE_EQUAL      reduce using rule 86 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 86 (value -> VARIABLE .)
    COMMA           reduce using rule 86 (value -> VARIABLE .)
    RPAREN          reduce using rule 86 (value -> VARIABLE .)
    COLON           shift and go to state 122


state 84

    (46) variableMutation -> VARIABLE immediateAssign value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

    SEMICOLON       reduce using rule 46 (variableMutation -> VARIABLE immediateAssign value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 85

    (54) prototype -> VARIABLE LPAREN values . RPAREN

    RPAREN          shift and go to state 124


state 86

    (55) prototype -> VARIABLE LPAREN RPAREN .

    SEMICOLON       reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    PLUS            reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    MINUS           reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    TIMES           reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    DIVIDE          reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    MOD             reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    BITWISE_XOR     reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    LOGICAL_AND     reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    LOGICAL_OR      reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    EQUALS          reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    LESS_THAN       reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    MORE_THAN       reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    LESS_EQUAL      reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    MORE_EQUAL      reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    COMMA           reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)
    RPAREN          reduce using rule 55 (prototype -> VARIABLE LPAREN RPAREN .)


state 87

    (52) values -> value . COMMA values
    (53) values -> value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

    COMMA           shift and go to state 125
    RPAREN          reduce using rule 53 (values -> value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 88

    (49) functionDeclaration -> datatype VARIABLE LPAREN . parameters RPAREN LBRACE body RBRACE
    (50) parameters -> . datatype VARIABLE COMMA parameters
    (51) parameters -> . datatype VARIABLE
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    datatype                       shift and go to state 126
    parameters                     shift and go to state 127
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 89

    (102) recordTypes -> LPAREN multipleDatatypes RPAREN .

    VARIABLE        reduce using rule 102 (recordTypes -> LPAREN multipleDatatypes RPAREN .)
    COMMA           reduce using rule 102 (recordTypes -> LPAREN multipleDatatypes RPAREN .)
    RPAREN          reduce using rule 102 (recordTypes -> LPAREN multipleDatatypes RPAREN .)


state 90

    (103) recordTypes -> LPAREN parameters RPAREN .

    VARIABLE        reduce using rule 103 (recordTypes -> LPAREN parameters RPAREN .)
    COMMA           reduce using rule 103 (recordTypes -> LPAREN parameters RPAREN .)
    RPAREN          reduce using rule 103 (recordTypes -> LPAREN parameters RPAREN .)


state 91

    (104) recordTypes -> LPAREN LBRACE recordTypeAnnotation . RBRACE RPAREN

    RBRACE          shift and go to state 128


state 92

    (105) recordTypeAnnotation -> datatype . VARIABLE COMMA recordTypeAnnotation
    (106) recordTypeAnnotation -> datatype . VARIABLE

    VARIABLE        shift and go to state 129


state 93

    (107) multipleDatatypes -> datatype COMMA . multipleDatatypes
    (107) multipleDatatypes -> . datatype COMMA multipleDatatypes
    (108) multipleDatatypes -> . datatype
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    datatype                       shift and go to state 130
    multipleDatatypes              shift and go to state 131
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 94

    (50) parameters -> datatype VARIABLE . COMMA parameters
    (51) parameters -> datatype VARIABLE .

    COMMA           shift and go to state 132
    RPAREN          reduce using rule 51 (parameters -> datatype VARIABLE .)


state 95

    (8) if -> IF LPAREN value . RPAREN LBRACE body RBRACE
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

    RPAREN          shift and go to state 133
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 96

    (98) arithmeticExpression -> value arithmeticOperator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 134
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 97

    (100) bitwiseExpression -> value bitwiseOperator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 135
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 98

    (96) logicExpression -> value logicOperator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 136
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 99

    (94) comparison -> value comparator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 137
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 100

    (61) arithmeticOperator -> PLUS .

    MINUS           reduce using rule 61 (arithmeticOperator -> PLUS .)
    NOT             reduce using rule 61 (arithmeticOperator -> PLUS .)
    STRING          reduce using rule 61 (arithmeticOperator -> PLUS .)
    VARIABLE        reduce using rule 61 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 61 (arithmeticOperator -> PLUS .)
    DOUBLE          reduce using rule 61 (arithmeticOperator -> PLUS .)
    NEW             reduce using rule 61 (arithmeticOperator -> PLUS .)
    LPAREN          reduce using rule 61 (arithmeticOperator -> PLUS .)
    TRUE            reduce using rule 61 (arithmeticOperator -> PLUS .)
    FALSE           reduce using rule 61 (arithmeticOperator -> PLUS .)


state 101

    (62) arithmeticOperator -> MINUS .

    MINUS           reduce using rule 62 (arithmeticOperator -> MINUS .)
    NOT             reduce using rule 62 (arithmeticOperator -> MINUS .)
    STRING          reduce using rule 62 (arithmeticOperator -> MINUS .)
    VARIABLE        reduce using rule 62 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 62 (arithmeticOperator -> MINUS .)
    DOUBLE          reduce using rule 62 (arithmeticOperator -> MINUS .)
    NEW             reduce using rule 62 (arithmeticOperator -> MINUS .)
    LPAREN          reduce using rule 62 (arithmeticOperator -> MINUS .)
    TRUE            reduce using rule 62 (arithmeticOperator -> MINUS .)
    FALSE           reduce using rule 62 (arithmeticOperator -> MINUS .)


state 102

    (63) arithmeticOperator -> TIMES .

    MINUS           reduce using rule 63 (arithmeticOperator -> TIMES .)
    NOT             reduce using rule 63 (arithmeticOperator -> TIMES .)
    STRING          reduce using rule 63 (arithmeticOperator -> TIMES .)
    VARIABLE        reduce using rule 63 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 63 (arithmeticOperator -> TIMES .)
    DOUBLE          reduce using rule 63 (arithmeticOperator -> TIMES .)
    NEW             reduce using rule 63 (arithmeticOperator -> TIMES .)
    LPAREN          reduce using rule 63 (arithmeticOperator -> TIMES .)
    TRUE            reduce using rule 63 (arithmeticOperator -> TIMES .)
    FALSE           reduce using rule 63 (arithmeticOperator -> TIMES .)


state 103

    (64) arithmeticOperator -> DIVIDE .

    MINUS           reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    NOT             reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    STRING          reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    VARIABLE        reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    DOUBLE          reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    NEW             reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    LPAREN          reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    TRUE            reduce using rule 64 (arithmeticOperator -> DIVIDE .)
    FALSE           reduce using rule 64 (arithmeticOperator -> DIVIDE .)


state 104

    (65) arithmeticOperator -> MOD .

    MINUS           reduce using rule 65 (arithmeticOperator -> MOD .)
    NOT             reduce using rule 65 (arithmeticOperator -> MOD .)
    STRING          reduce using rule 65 (arithmeticOperator -> MOD .)
    VARIABLE        reduce using rule 65 (arithmeticOperator -> MOD .)
    INTEGER         reduce using rule 65 (arithmeticOperator -> MOD .)
    DOUBLE          reduce using rule 65 (arithmeticOperator -> MOD .)
    NEW             reduce using rule 65 (arithmeticOperator -> MOD .)
    LPAREN          reduce using rule 65 (arithmeticOperator -> MOD .)
    TRUE            reduce using rule 65 (arithmeticOperator -> MOD .)
    FALSE           reduce using rule 65 (arithmeticOperator -> MOD .)


state 105

    (68) bitwiseOperator -> BITWISE_AND .

    MINUS           reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    NOT             reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    STRING          reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    VARIABLE        reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    INTEGER         reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    DOUBLE          reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    NEW             reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    LPAREN          reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    TRUE            reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)
    FALSE           reduce using rule 68 (bitwiseOperator -> BITWISE_AND .)


state 106

    (69) bitwiseOperator -> BITWISE_OR .

    MINUS           reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    NOT             reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    STRING          reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    VARIABLE        reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    INTEGER         reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    DOUBLE          reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    NEW             reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    LPAREN          reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    TRUE            reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)
    FALSE           reduce using rule 69 (bitwiseOperator -> BITWISE_OR .)


state 107

    (70) bitwiseOperator -> BITWISE_XOR .

    MINUS           reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    NOT             reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    STRING          reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    VARIABLE        reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    INTEGER         reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    DOUBLE          reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    NEW             reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    LPAREN          reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    TRUE            reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)
    FALSE           reduce using rule 70 (bitwiseOperator -> BITWISE_XOR .)


state 108

    (66) logicOperator -> LOGICAL_AND .

    MINUS           reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    NOT             reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    STRING          reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    VARIABLE        reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    INTEGER         reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    DOUBLE          reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    NEW             reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    LPAREN          reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    TRUE            reduce using rule 66 (logicOperator -> LOGICAL_AND .)
    FALSE           reduce using rule 66 (logicOperator -> LOGICAL_AND .)


state 109

    (67) logicOperator -> LOGICAL_OR .

    MINUS           reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    NOT             reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    STRING          reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    VARIABLE        reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    INTEGER         reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    DOUBLE          reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    NEW             reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    LPAREN          reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    TRUE            reduce using rule 67 (logicOperator -> LOGICAL_OR .)
    FALSE           reduce using rule 67 (logicOperator -> LOGICAL_OR .)


state 110

    (71) comparator -> EQUALS .

    MINUS           reduce using rule 71 (comparator -> EQUALS .)
    NOT             reduce using rule 71 (comparator -> EQUALS .)
    STRING          reduce using rule 71 (comparator -> EQUALS .)
    VARIABLE        reduce using rule 71 (comparator -> EQUALS .)
    INTEGER         reduce using rule 71 (comparator -> EQUALS .)
    DOUBLE          reduce using rule 71 (comparator -> EQUALS .)
    NEW             reduce using rule 71 (comparator -> EQUALS .)
    LPAREN          reduce using rule 71 (comparator -> EQUALS .)
    TRUE            reduce using rule 71 (comparator -> EQUALS .)
    FALSE           reduce using rule 71 (comparator -> EQUALS .)


state 111

    (72) comparator -> LESS_THAN .

    MINUS           reduce using rule 72 (comparator -> LESS_THAN .)
    NOT             reduce using rule 72 (comparator -> LESS_THAN .)
    STRING          reduce using rule 72 (comparator -> LESS_THAN .)
    VARIABLE        reduce using rule 72 (comparator -> LESS_THAN .)
    INTEGER         reduce using rule 72 (comparator -> LESS_THAN .)
    DOUBLE          reduce using rule 72 (comparator -> LESS_THAN .)
    NEW             reduce using rule 72 (comparator -> LESS_THAN .)
    LPAREN          reduce using rule 72 (comparator -> LESS_THAN .)
    TRUE            reduce using rule 72 (comparator -> LESS_THAN .)
    FALSE           reduce using rule 72 (comparator -> LESS_THAN .)


state 112

    (73) comparator -> MORE_THAN .

    MINUS           reduce using rule 73 (comparator -> MORE_THAN .)
    NOT             reduce using rule 73 (comparator -> MORE_THAN .)
    STRING          reduce using rule 73 (comparator -> MORE_THAN .)
    VARIABLE        reduce using rule 73 (comparator -> MORE_THAN .)
    INTEGER         reduce using rule 73 (comparator -> MORE_THAN .)
    DOUBLE          reduce using rule 73 (comparator -> MORE_THAN .)
    NEW             reduce using rule 73 (comparator -> MORE_THAN .)
    LPAREN          reduce using rule 73 (comparator -> MORE_THAN .)
    TRUE            reduce using rule 73 (comparator -> MORE_THAN .)
    FALSE           reduce using rule 73 (comparator -> MORE_THAN .)


state 113

    (74) comparator -> LESS_EQUAL .

    MINUS           reduce using rule 74 (comparator -> LESS_EQUAL .)
    NOT             reduce using rule 74 (comparator -> LESS_EQUAL .)
    STRING          reduce using rule 74 (comparator -> LESS_EQUAL .)
    VARIABLE        reduce using rule 74 (comparator -> LESS_EQUAL .)
    INTEGER         reduce using rule 74 (comparator -> LESS_EQUAL .)
    DOUBLE          reduce using rule 74 (comparator -> LESS_EQUAL .)
    NEW             reduce using rule 74 (comparator -> LESS_EQUAL .)
    LPAREN          reduce using rule 74 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 74 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 74 (comparator -> LESS_EQUAL .)


state 114

    (75) comparator -> MORE_EQUAL .

    MINUS           reduce using rule 75 (comparator -> MORE_EQUAL .)
    NOT             reduce using rule 75 (comparator -> MORE_EQUAL .)
    STRING          reduce using rule 75 (comparator -> MORE_EQUAL .)
    VARIABLE        reduce using rule 75 (comparator -> MORE_EQUAL .)
    INTEGER         reduce using rule 75 (comparator -> MORE_EQUAL .)
    DOUBLE          reduce using rule 75 (comparator -> MORE_EQUAL .)
    NEW             reduce using rule 75 (comparator -> MORE_EQUAL .)
    LPAREN          reduce using rule 75 (comparator -> MORE_EQUAL .)
    TRUE            reduce using rule 75 (comparator -> MORE_EQUAL .)
    FALSE           reduce using rule 75 (comparator -> MORE_EQUAL .)


state 115

    (77) value -> MINUS number .

    PLUS            reduce using rule 77 (value -> MINUS number .)
    MINUS           reduce using rule 77 (value -> MINUS number .)
    TIMES           reduce using rule 77 (value -> MINUS number .)
    DIVIDE          reduce using rule 77 (value -> MINUS number .)
    MOD             reduce using rule 77 (value -> MINUS number .)
    BITWISE_AND     reduce using rule 77 (value -> MINUS number .)
    BITWISE_OR      reduce using rule 77 (value -> MINUS number .)
    BITWISE_XOR     reduce using rule 77 (value -> MINUS number .)
    LOGICAL_AND     reduce using rule 77 (value -> MINUS number .)
    LOGICAL_OR      reduce using rule 77 (value -> MINUS number .)
    EQUALS          reduce using rule 77 (value -> MINUS number .)
    LESS_THAN       reduce using rule 77 (value -> MINUS number .)
    MORE_THAN       reduce using rule 77 (value -> MINUS number .)
    LESS_EQUAL      reduce using rule 77 (value -> MINUS number .)
    MORE_EQUAL      reduce using rule 77 (value -> MINUS number .)
    SEMICOLON       reduce using rule 77 (value -> MINUS number .)
    COMMA           reduce using rule 77 (value -> MINUS number .)
    RPAREN          reduce using rule 77 (value -> MINUS number .)


state 116

    (80) value -> MINUS LPAREN . arithmeticExpression RPAREN
    (82) value -> MINUS LPAREN . bitwiseExpression RPAREN
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    arithmeticExpression           shift and go to state 138
    bitwiseExpression              shift and go to state 139
    value                          shift and go to state 140
    number                         shift and go to state 62
    object                         shift and go to state 64
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 117

    (99) arithmeticExpression -> LPAREN value . arithmeticOperator value RPAREN
    (101) bitwiseExpression -> LPAREN value . bitwiseOperator value RPAREN
    (97) logicExpression -> LPAREN value . logicOperator value RPAREN
    (95) comparison -> LPAREN value . comparator value RPAREN
    (52) values -> value . COMMA values
    (53) values -> value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

    COMMA           shift and go to state 125
    RPAREN          reduce using rule 53 (values -> value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

    arithmeticOperator             shift and go to state 141
    bitwiseOperator                shift and go to state 142
    logicOperator                  shift and go to state 143
    comparator                     shift and go to state 144

state 118

    (110) tuple -> LPAREN values . RPAREN

    RPAREN          shift and go to state 145


state 119

    (84) value -> NOT LPAREN . logicExpression RPAREN
    (93) value -> NOT LPAREN . comparison RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN

    LPAREN          shift and go to state 146
    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    logicExpression                shift and go to state 147
    comparison                     shift and go to state 148
    value                          shift and go to state 149
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74

state 120

    (87) value -> NOT VARIABLE .

    PLUS            reduce using rule 87 (value -> NOT VARIABLE .)
    MINUS           reduce using rule 87 (value -> NOT VARIABLE .)
    TIMES           reduce using rule 87 (value -> NOT VARIABLE .)
    DIVIDE          reduce using rule 87 (value -> NOT VARIABLE .)
    MOD             reduce using rule 87 (value -> NOT VARIABLE .)
    BITWISE_AND     reduce using rule 87 (value -> NOT VARIABLE .)
    BITWISE_OR      reduce using rule 87 (value -> NOT VARIABLE .)
    BITWISE_XOR     reduce using rule 87 (value -> NOT VARIABLE .)
    LOGICAL_AND     reduce using rule 87 (value -> NOT VARIABLE .)
    LOGICAL_OR      reduce using rule 87 (value -> NOT VARIABLE .)
    EQUALS          reduce using rule 87 (value -> NOT VARIABLE .)
    LESS_THAN       reduce using rule 87 (value -> NOT VARIABLE .)
    MORE_THAN       reduce using rule 87 (value -> NOT VARIABLE .)
    LESS_EQUAL      reduce using rule 87 (value -> NOT VARIABLE .)
    MORE_EQUAL      reduce using rule 87 (value -> NOT VARIABLE .)
    SEMICOLON       reduce using rule 87 (value -> NOT VARIABLE .)
    COMMA           reduce using rule 87 (value -> NOT VARIABLE .)
    RPAREN          reduce using rule 87 (value -> NOT VARIABLE .)


state 121

    (89) value -> NOT boolean .

    PLUS            reduce using rule 89 (value -> NOT boolean .)
    MINUS           reduce using rule 89 (value -> NOT boolean .)
    TIMES           reduce using rule 89 (value -> NOT boolean .)
    DIVIDE          reduce using rule 89 (value -> NOT boolean .)
    MOD             reduce using rule 89 (value -> NOT boolean .)
    BITWISE_AND     reduce using rule 89 (value -> NOT boolean .)
    BITWISE_OR      reduce using rule 89 (value -> NOT boolean .)
    BITWISE_XOR     reduce using rule 89 (value -> NOT boolean .)
    LOGICAL_AND     reduce using rule 89 (value -> NOT boolean .)
    LOGICAL_OR      reduce using rule 89 (value -> NOT boolean .)
    EQUALS          reduce using rule 89 (value -> NOT boolean .)
    LESS_THAN       reduce using rule 89 (value -> NOT boolean .)
    MORE_THAN       reduce using rule 89 (value -> NOT boolean .)
    LESS_EQUAL      reduce using rule 89 (value -> NOT boolean .)
    MORE_EQUAL      reduce using rule 89 (value -> NOT boolean .)
    SEMICOLON       reduce using rule 89 (value -> NOT boolean .)
    COMMA           reduce using rule 89 (value -> NOT boolean .)
    RPAREN          reduce using rule 89 (value -> NOT boolean .)


state 122

    (109) variableValuePair -> VARIABLE COLON . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 150
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 123

    (56) object -> NEW prototype .

    PLUS            reduce using rule 56 (object -> NEW prototype .)
    MINUS           reduce using rule 56 (object -> NEW prototype .)
    TIMES           reduce using rule 56 (object -> NEW prototype .)
    DIVIDE          reduce using rule 56 (object -> NEW prototype .)
    MOD             reduce using rule 56 (object -> NEW prototype .)
    BITWISE_AND     reduce using rule 56 (object -> NEW prototype .)
    BITWISE_OR      reduce using rule 56 (object -> NEW prototype .)
    BITWISE_XOR     reduce using rule 56 (object -> NEW prototype .)
    LOGICAL_AND     reduce using rule 56 (object -> NEW prototype .)
    LOGICAL_OR      reduce using rule 56 (object -> NEW prototype .)
    EQUALS          reduce using rule 56 (object -> NEW prototype .)
    LESS_THAN       reduce using rule 56 (object -> NEW prototype .)
    MORE_THAN       reduce using rule 56 (object -> NEW prototype .)
    LESS_EQUAL      reduce using rule 56 (object -> NEW prototype .)
    MORE_EQUAL      reduce using rule 56 (object -> NEW prototype .)
    SEMICOLON       reduce using rule 56 (object -> NEW prototype .)
    COMMA           reduce using rule 56 (object -> NEW prototype .)
    RPAREN          reduce using rule 56 (object -> NEW prototype .)


state 124

    (54) prototype -> VARIABLE LPAREN values RPAREN .

    SEMICOLON       reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    PLUS            reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    MINUS           reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    TIMES           reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    DIVIDE          reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    MOD             reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    BITWISE_AND     reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    BITWISE_OR      reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    BITWISE_XOR     reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    EQUALS          reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    LESS_THAN       reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    MORE_THAN       reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    MORE_EQUAL      reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    COMMA           reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)
    RPAREN          reduce using rule 54 (prototype -> VARIABLE LPAREN values RPAREN .)


state 125

    (52) values -> value COMMA . values
    (52) values -> . value COMMA values
    (53) values -> . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 87
    values                         shift and go to state 151
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 126

    (50) parameters -> datatype . VARIABLE COMMA parameters
    (51) parameters -> datatype . VARIABLE

    VARIABLE        shift and go to state 94


state 127

    (49) functionDeclaration -> datatype VARIABLE LPAREN parameters . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 152


state 128

    (104) recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE . RPAREN

    RPAREN          shift and go to state 153


state 129

    (105) recordTypeAnnotation -> datatype VARIABLE . COMMA recordTypeAnnotation
    (106) recordTypeAnnotation -> datatype VARIABLE .

    COMMA           shift and go to state 154
    RBRACE          reduce using rule 106 (recordTypeAnnotation -> datatype VARIABLE .)


state 130

    (107) multipleDatatypes -> datatype . COMMA multipleDatatypes
    (108) multipleDatatypes -> datatype .

    COMMA           shift and go to state 93
    RPAREN          reduce using rule 108 (multipleDatatypes -> datatype .)


state 131

    (107) multipleDatatypes -> datatype COMMA multipleDatatypes .

    RPAREN          reduce using rule 107 (multipleDatatypes -> datatype COMMA multipleDatatypes .)


state 132

    (50) parameters -> datatype VARIABLE COMMA . parameters
    (50) parameters -> . datatype VARIABLE COMMA parameters
    (51) parameters -> . datatype VARIABLE
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    datatype                       shift and go to state 126
    parameters                     shift and go to state 155
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 133

    (8) if -> IF LPAREN value RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 156


state 134

    (98) arithmeticExpression -> value arithmeticOperator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    SEMICOLON       reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .)
    COMMA           reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .)
    RPAREN          reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MINUS           [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! TIMES           [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! DIVIDE          [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MOD             [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! EQUALS          [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LESS_THAN       [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MORE_THAN       [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LESS_EQUAL      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MORE_EQUAL      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 135

    (100) bitwiseExpression -> value bitwiseOperator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    SEMICOLON       reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .)
    COMMA           reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .)
    RPAREN          reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MINUS           [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! TIMES           [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! DIVIDE          [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MOD             [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! EQUALS          [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LESS_THAN       [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MORE_THAN       [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LESS_EQUAL      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MORE_EQUAL      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]

    bitwiseOperator                shift and go to state 97
    arithmeticOperator             shift and go to state 96
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 136

    (96) logicExpression -> value logicOperator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    SEMICOLON       reduce using rule 96 (logicExpression -> value logicOperator value .)
    COMMA           reduce using rule 96 (logicExpression -> value logicOperator value .)
    RPAREN          reduce using rule 96 (logicExpression -> value logicOperator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MINUS           [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! TIMES           [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! DIVIDE          [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MOD             [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! EQUALS          [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LESS_THAN       [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MORE_THAN       [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LESS_EQUAL      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MORE_EQUAL      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]

    logicOperator                  shift and go to state 98
    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    comparator                     shift and go to state 99

state 137

    (94) comparison -> value comparator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    SEMICOLON       reduce using rule 94 (comparison -> value comparator value .)
    COMMA           reduce using rule 94 (comparison -> value comparator value .)
    RPAREN          reduce using rule 94 (comparison -> value comparator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MINUS           [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! TIMES           [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! DIVIDE          [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MOD             [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! BITWISE_AND     [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! BITWISE_OR      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! BITWISE_XOR     [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LOGICAL_AND     [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LOGICAL_OR      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! EQUALS          [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LESS_THAN       [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MORE_THAN       [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LESS_EQUAL      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MORE_EQUAL      [ reduce using rule 94 (comparison -> value comparator value .) ]

    comparator                     shift and go to state 99
    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98

state 138

    (80) value -> MINUS LPAREN arithmeticExpression . RPAREN
    (79) value -> arithmeticExpression .

    RPAREN          shift and go to state 157
    PLUS            reduce using rule 79 (value -> arithmeticExpression .)
    MINUS           reduce using rule 79 (value -> arithmeticExpression .)
    TIMES           reduce using rule 79 (value -> arithmeticExpression .)
    DIVIDE          reduce using rule 79 (value -> arithmeticExpression .)
    MOD             reduce using rule 79 (value -> arithmeticExpression .)
    BITWISE_AND     reduce using rule 79 (value -> arithmeticExpression .)
    BITWISE_OR      reduce using rule 79 (value -> arithmeticExpression .)
    BITWISE_XOR     reduce using rule 79 (value -> arithmeticExpression .)
    LOGICAL_AND     reduce using rule 79 (value -> arithmeticExpression .)
    LOGICAL_OR      reduce using rule 79 (value -> arithmeticExpression .)
    EQUALS          reduce using rule 79 (value -> arithmeticExpression .)
    LESS_THAN       reduce using rule 79 (value -> arithmeticExpression .)
    MORE_THAN       reduce using rule 79 (value -> arithmeticExpression .)
    LESS_EQUAL      reduce using rule 79 (value -> arithmeticExpression .)
    MORE_EQUAL      reduce using rule 79 (value -> arithmeticExpression .)


state 139

    (82) value -> MINUS LPAREN bitwiseExpression . RPAREN
    (81) value -> bitwiseExpression .

    RPAREN          shift and go to state 158
    PLUS            reduce using rule 81 (value -> bitwiseExpression .)
    MINUS           reduce using rule 81 (value -> bitwiseExpression .)
    TIMES           reduce using rule 81 (value -> bitwiseExpression .)
    DIVIDE          reduce using rule 81 (value -> bitwiseExpression .)
    MOD             reduce using rule 81 (value -> bitwiseExpression .)
    BITWISE_AND     reduce using rule 81 (value -> bitwiseExpression .)
    BITWISE_OR      reduce using rule 81 (value -> bitwiseExpression .)
    BITWISE_XOR     reduce using rule 81 (value -> bitwiseExpression .)
    LOGICAL_AND     reduce using rule 81 (value -> bitwiseExpression .)
    LOGICAL_OR      reduce using rule 81 (value -> bitwiseExpression .)
    EQUALS          reduce using rule 81 (value -> bitwiseExpression .)
    LESS_THAN       reduce using rule 81 (value -> bitwiseExpression .)
    MORE_THAN       reduce using rule 81 (value -> bitwiseExpression .)
    LESS_EQUAL      reduce using rule 81 (value -> bitwiseExpression .)
    MORE_EQUAL      reduce using rule 81 (value -> bitwiseExpression .)


state 140

    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 141

    (99) arithmeticExpression -> LPAREN value arithmeticOperator . value RPAREN
    (98) arithmeticExpression -> value arithmeticOperator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 159
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 142

    (101) bitwiseExpression -> LPAREN value bitwiseOperator . value RPAREN
    (100) bitwiseExpression -> value bitwiseOperator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 160
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 143

    (97) logicExpression -> LPAREN value logicOperator . value RPAREN
    (96) logicExpression -> value logicOperator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 161
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 144

    (95) comparison -> LPAREN value comparator . value RPAREN
    (94) comparison -> value comparator . value
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 162
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 145

    (110) tuple -> LPAREN values RPAREN .

    PLUS            reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    MINUS           reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    TIMES           reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    DIVIDE          reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    MOD             reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    BITWISE_AND     reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    BITWISE_OR      reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    BITWISE_XOR     reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    EQUALS          reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    LESS_THAN       reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    MORE_THAN       reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    MORE_EQUAL      reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    SEMICOLON       reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    COMMA           reduce using rule 110 (tuple -> LPAREN values RPAREN .)
    RPAREN          reduce using rule 110 (tuple -> LPAREN values RPAREN .)


state 146

    (97) logicExpression -> LPAREN . value logicOperator value RPAREN
    (95) comparison -> LPAREN . value comparator value RPAREN
    (99) arithmeticExpression -> LPAREN . value arithmeticOperator value RPAREN
    (101) bitwiseExpression -> LPAREN . value bitwiseOperator value RPAREN
    (110) tuple -> LPAREN . values RPAREN
    (76) value -> . number
    (77) value -> . MINUS number
    (78) value -> . object
    (79) value -> . arithmeticExpression
    (80) value -> . MINUS LPAREN arithmeticExpression RPAREN
    (81) value -> . bitwiseExpression
    (82) value -> . MINUS LPAREN bitwiseExpression RPAREN
    (83) value -> . logicExpression
    (84) value -> . NOT LPAREN logicExpression RPAREN
    (85) value -> . STRING
    (86) value -> . VARIABLE
    (87) value -> . NOT VARIABLE
    (88) value -> . boolean
    (89) value -> . NOT boolean
    (90) value -> . variableValuePair
    (91) value -> . tuple
    (92) value -> . comparison
    (93) value -> . NOT LPAREN comparison RPAREN
    (52) values -> . value COMMA values
    (53) values -> . value
    (59) number -> . INTEGER
    (60) number -> . DOUBLE
    (56) object -> . NEW prototype
    (98) arithmeticExpression -> . value arithmeticOperator value
    (99) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (100) bitwiseExpression -> . value bitwiseOperator value
    (101) bitwiseExpression -> . LPAREN value bitwiseOperator value RPAREN
    (96) logicExpression -> . value logicOperator value
    (97) logicExpression -> . LPAREN value logicOperator value RPAREN
    (57) boolean -> . TRUE
    (58) boolean -> . FALSE
    (109) variableValuePair -> . VARIABLE COLON value
    (110) tuple -> . LPAREN values RPAREN
    (94) comparison -> . value comparator value
    (95) comparison -> . LPAREN value comparator value RPAREN

    MINUS           shift and go to state 63
    NOT             shift and go to state 69
    STRING          shift and go to state 70
    VARIABLE        shift and go to state 83
    INTEGER         shift and go to state 76
    DOUBLE          shift and go to state 77
    NEW             shift and go to state 78
    LPAREN          shift and go to state 66
    TRUE            shift and go to state 79
    FALSE           shift and go to state 80

    value                          shift and go to state 163
    values                         shift and go to state 118
    number                         shift and go to state 62
    object                         shift and go to state 64
    arithmeticExpression           shift and go to state 65
    bitwiseExpression              shift and go to state 67
    logicExpression                shift and go to state 68
    boolean                        shift and go to state 72
    variableValuePair              shift and go to state 73
    tuple                          shift and go to state 74
    comparison                     shift and go to state 75

state 147

    (84) value -> NOT LPAREN logicExpression . RPAREN
    (83) value -> logicExpression .

    RPAREN          shift and go to state 164
    LOGICAL_AND     reduce using rule 83 (value -> logicExpression .)
    LOGICAL_OR      reduce using rule 83 (value -> logicExpression .)
    EQUALS          reduce using rule 83 (value -> logicExpression .)
    LESS_THAN       reduce using rule 83 (value -> logicExpression .)
    MORE_THAN       reduce using rule 83 (value -> logicExpression .)
    LESS_EQUAL      reduce using rule 83 (value -> logicExpression .)
    MORE_EQUAL      reduce using rule 83 (value -> logicExpression .)
    PLUS            reduce using rule 83 (value -> logicExpression .)
    MINUS           reduce using rule 83 (value -> logicExpression .)
    TIMES           reduce using rule 83 (value -> logicExpression .)
    DIVIDE          reduce using rule 83 (value -> logicExpression .)
    MOD             reduce using rule 83 (value -> logicExpression .)
    BITWISE_AND     reduce using rule 83 (value -> logicExpression .)
    BITWISE_OR      reduce using rule 83 (value -> logicExpression .)
    BITWISE_XOR     reduce using rule 83 (value -> logicExpression .)


state 148

    (93) value -> NOT LPAREN comparison . RPAREN
    (92) value -> comparison .

    RPAREN          shift and go to state 165
    LOGICAL_AND     reduce using rule 92 (value -> comparison .)
    LOGICAL_OR      reduce using rule 92 (value -> comparison .)
    EQUALS          reduce using rule 92 (value -> comparison .)
    LESS_THAN       reduce using rule 92 (value -> comparison .)
    MORE_THAN       reduce using rule 92 (value -> comparison .)
    LESS_EQUAL      reduce using rule 92 (value -> comparison .)
    MORE_EQUAL      reduce using rule 92 (value -> comparison .)
    PLUS            reduce using rule 92 (value -> comparison .)
    MINUS           reduce using rule 92 (value -> comparison .)
    TIMES           reduce using rule 92 (value -> comparison .)
    DIVIDE          reduce using rule 92 (value -> comparison .)
    MOD             reduce using rule 92 (value -> comparison .)
    BITWISE_AND     reduce using rule 92 (value -> comparison .)
    BITWISE_OR      reduce using rule 92 (value -> comparison .)
    BITWISE_XOR     reduce using rule 92 (value -> comparison .)


state 149

    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR

    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107

    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99
    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97

state 150

    (109) variableValuePair -> VARIABLE COLON value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    SEMICOLON       reduce using rule 109 (variableValuePair -> VARIABLE COLON value .)
    COMMA           reduce using rule 109 (variableValuePair -> VARIABLE COLON value .)
    RPAREN          reduce using rule 109 (variableValuePair -> VARIABLE COLON value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! MINUS           [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! TIMES           [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! DIVIDE          [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! MOD             [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! BITWISE_AND     [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! BITWISE_OR      [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! BITWISE_XOR     [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! LOGICAL_AND     [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! LOGICAL_OR      [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! EQUALS          [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! LESS_THAN       [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! MORE_THAN       [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! LESS_EQUAL      [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]
  ! MORE_EQUAL      [ reduce using rule 109 (variableValuePair -> VARIABLE COLON value .) ]

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 151

    (52) values -> value COMMA values .

    RPAREN          reduce using rule 52 (values -> value COMMA values .)


state 152

    (49) functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 166


state 153

    (104) recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .

    VARIABLE        reduce using rule 104 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)
    COMMA           reduce using rule 104 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)
    RPAREN          reduce using rule 104 (recordTypes -> LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN .)


state 154

    (105) recordTypeAnnotation -> datatype VARIABLE COMMA . recordTypeAnnotation
    (105) recordTypeAnnotation -> . datatype VARIABLE COMMA recordTypeAnnotation
    (106) recordTypeAnnotation -> . datatype VARIABLE
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    datatype                       shift and go to state 92
    recordTypeAnnotation           shift and go to state 167
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 155

    (50) parameters -> datatype VARIABLE COMMA parameters .

    RPAREN          reduce using rule 50 (parameters -> datatype VARIABLE COMMA parameters .)


state 156

    (8) if -> IF LPAREN value RPAREN LBRACE . body RBRACE
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . noSemicolonStructure body
    (4) body -> . noSemicolonStructure
    (10) instruction -> . functionCall
    (11) instruction -> . variableDeclarationUninitialized
    (12) instruction -> . variableDeclarationInitialized
    (13) instruction -> . variableMutation
    (14) instruction -> . import
    (5) noSemicolonStructure -> . dataStructure
    (6) noSemicolonStructure -> . functionDeclaration
    (47) functionCall -> . prototype
    (48) functionCall -> . VARIABLE DOT prototype
    (30) variableDeclarationUninitialized -> . datatype VARIABLE
    (33) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (45) variableMutation -> . VARIABLE variableInitialization
    (46) variableMutation -> . VARIABLE immediateAssign value
    (9) import -> . IMPORT STRING
    (7) dataStructure -> . if
    (49) functionDeclaration -> . datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (8) if -> . IF LPAREN value RPAREN LBRACE body RBRACE
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 14
    IF              shift and go to state 20
    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    body                           shift and go to state 168
    instruction                    shift and go to state 2
    noSemicolonStructure           shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    dataStructure                  shift and go to state 9
    functionDeclaration            shift and go to state 10
    prototype                      shift and go to state 11
    datatype                       shift and go to state 13
    if                             shift and go to state 15
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 157

    (80) value -> MINUS LPAREN arithmeticExpression RPAREN .

    PLUS            reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    MINUS           reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    TIMES           reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    DIVIDE          reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    MOD             reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    BITWISE_AND     reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    BITWISE_OR      reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    BITWISE_XOR     reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    LOGICAL_AND     reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    LOGICAL_OR      reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    EQUALS          reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    LESS_THAN       reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    MORE_THAN       reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    LESS_EQUAL      reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    MORE_EQUAL      reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    SEMICOLON       reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    COMMA           reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)
    RPAREN          reduce using rule 80 (value -> MINUS LPAREN arithmeticExpression RPAREN .)


state 158

    (82) value -> MINUS LPAREN bitwiseExpression RPAREN .

    PLUS            reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    MINUS           reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    TIMES           reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    DIVIDE          reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    MOD             reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    BITWISE_AND     reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    BITWISE_OR      reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    BITWISE_XOR     reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    LOGICAL_AND     reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    LOGICAL_OR      reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    EQUALS          reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    LESS_THAN       reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    MORE_THAN       reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    LESS_EQUAL      reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    MORE_EQUAL      reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    SEMICOLON       reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    COMMA           reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)
    RPAREN          reduce using rule 82 (value -> MINUS LPAREN bitwiseExpression RPAREN .)


state 159

    (99) arithmeticExpression -> LPAREN value arithmeticOperator value . RPAREN
    (98) arithmeticExpression -> value arithmeticOperator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    RPAREN          shift and go to state 169
    COMMA           reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MINUS           [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! TIMES           [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! DIVIDE          [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MOD             [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! EQUALS          [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LESS_THAN       [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MORE_THAN       [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! LESS_EQUAL      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MORE_EQUAL      [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! RPAREN          [ reduce using rule 98 (arithmeticExpression -> value arithmeticOperator value .) ]

    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 160

    (101) bitwiseExpression -> LPAREN value bitwiseOperator value . RPAREN
    (100) bitwiseExpression -> value bitwiseOperator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    RPAREN          shift and go to state 170
    COMMA           reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MINUS           [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! TIMES           [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! DIVIDE          [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MOD             [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! EQUALS          [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LESS_THAN       [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MORE_THAN       [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! LESS_EQUAL      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! MORE_EQUAL      [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]
  ! RPAREN          [ reduce using rule 100 (bitwiseExpression -> value bitwiseOperator value .) ]

    bitwiseOperator                shift and go to state 97
    arithmeticOperator             shift and go to state 96
    logicOperator                  shift and go to state 98
    comparator                     shift and go to state 99

state 161

    (97) logicExpression -> LPAREN value logicOperator value . RPAREN
    (96) logicExpression -> value logicOperator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    RPAREN          shift and go to state 171
    COMMA           reduce using rule 96 (logicExpression -> value logicOperator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MINUS           [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! TIMES           [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! DIVIDE          [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MOD             [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_AND     [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_OR      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! BITWISE_XOR     [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_AND     [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LOGICAL_OR      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! EQUALS          [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LESS_THAN       [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MORE_THAN       [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! LESS_EQUAL      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! MORE_EQUAL      [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]
  ! RPAREN          [ reduce using rule 96 (logicExpression -> value logicOperator value .) ]

    logicOperator                  shift and go to state 98
    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    comparator                     shift and go to state 99

state 162

    (95) comparison -> LPAREN value comparator value . RPAREN
    (94) comparison -> value comparator value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for BITWISE_XOR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for MORE_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for MORE_EQUAL resolved as shift
    RPAREN          shift and go to state 172
    COMMA           reduce using rule 94 (comparison -> value comparator value .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114

  ! PLUS            [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MINUS           [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! TIMES           [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! DIVIDE          [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MOD             [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! BITWISE_AND     [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! BITWISE_OR      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! BITWISE_XOR     [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LOGICAL_AND     [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LOGICAL_OR      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! EQUALS          [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LESS_THAN       [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MORE_THAN       [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! LESS_EQUAL      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! MORE_EQUAL      [ reduce using rule 94 (comparison -> value comparator value .) ]
  ! RPAREN          [ reduce using rule 94 (comparison -> value comparator value .) ]

    comparator                     shift and go to state 99
    arithmeticOperator             shift and go to state 96
    bitwiseOperator                shift and go to state 97
    logicOperator                  shift and go to state 98

state 163

    (97) logicExpression -> LPAREN value . logicOperator value RPAREN
    (95) comparison -> LPAREN value . comparator value RPAREN
    (99) arithmeticExpression -> LPAREN value . arithmeticOperator value RPAREN
    (101) bitwiseExpression -> LPAREN value . bitwiseOperator value RPAREN
    (52) values -> value . COMMA values
    (53) values -> value .
    (98) arithmeticExpression -> value . arithmeticOperator value
    (100) bitwiseExpression -> value . bitwiseOperator value
    (96) logicExpression -> value . logicOperator value
    (94) comparison -> value . comparator value
    (66) logicOperator -> . LOGICAL_AND
    (67) logicOperator -> . LOGICAL_OR
    (71) comparator -> . EQUALS
    (72) comparator -> . LESS_THAN
    (73) comparator -> . MORE_THAN
    (74) comparator -> . LESS_EQUAL
    (75) comparator -> . MORE_EQUAL
    (61) arithmeticOperator -> . PLUS
    (62) arithmeticOperator -> . MINUS
    (63) arithmeticOperator -> . TIMES
    (64) arithmeticOperator -> . DIVIDE
    (65) arithmeticOperator -> . MOD
    (68) bitwiseOperator -> . BITWISE_AND
    (69) bitwiseOperator -> . BITWISE_OR
    (70) bitwiseOperator -> . BITWISE_XOR

    COMMA           shift and go to state 125
    RPAREN          reduce using rule 53 (values -> value .)
    LOGICAL_AND     shift and go to state 108
    LOGICAL_OR      shift and go to state 109
    EQUALS          shift and go to state 110
    LESS_THAN       shift and go to state 111
    MORE_THAN       shift and go to state 112
    LESS_EQUAL      shift and go to state 113
    MORE_EQUAL      shift and go to state 114
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    TIMES           shift and go to state 102
    DIVIDE          shift and go to state 103
    MOD             shift and go to state 104
    BITWISE_AND     shift and go to state 105
    BITWISE_OR      shift and go to state 106
    BITWISE_XOR     shift and go to state 107

    logicOperator                  shift and go to state 143
    comparator                     shift and go to state 144
    arithmeticOperator             shift and go to state 141
    bitwiseOperator                shift and go to state 142

state 164

    (84) value -> NOT LPAREN logicExpression RPAREN .

    PLUS            reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    MINUS           reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    TIMES           reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    DIVIDE          reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    MOD             reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    BITWISE_AND     reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    BITWISE_OR      reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    BITWISE_XOR     reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    LOGICAL_AND     reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    LOGICAL_OR      reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    EQUALS          reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    LESS_THAN       reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    MORE_THAN       reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    LESS_EQUAL      reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    MORE_EQUAL      reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    SEMICOLON       reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    COMMA           reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)
    RPAREN          reduce using rule 84 (value -> NOT LPAREN logicExpression RPAREN .)


state 165

    (93) value -> NOT LPAREN comparison RPAREN .

    PLUS            reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    MINUS           reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    TIMES           reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    DIVIDE          reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    MOD             reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    BITWISE_AND     reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    BITWISE_OR      reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    BITWISE_XOR     reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    LOGICAL_AND     reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    LOGICAL_OR      reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    EQUALS          reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    LESS_THAN       reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    MORE_THAN       reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    LESS_EQUAL      reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    MORE_EQUAL      reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    SEMICOLON       reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    COMMA           reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)
    RPAREN          reduce using rule 93 (value -> NOT LPAREN comparison RPAREN .)


state 166

    (49) functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE . body RBRACE
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) body -> . noSemicolonStructure body
    (4) body -> . noSemicolonStructure
    (10) instruction -> . functionCall
    (11) instruction -> . variableDeclarationUninitialized
    (12) instruction -> . variableDeclarationInitialized
    (13) instruction -> . variableMutation
    (14) instruction -> . import
    (5) noSemicolonStructure -> . dataStructure
    (6) noSemicolonStructure -> . functionDeclaration
    (47) functionCall -> . prototype
    (48) functionCall -> . VARIABLE DOT prototype
    (30) variableDeclarationUninitialized -> . datatype VARIABLE
    (33) variableDeclarationInitialized -> . variableDeclarationUninitialized variableInitialization
    (45) variableMutation -> . VARIABLE variableInitialization
    (46) variableMutation -> . VARIABLE immediateAssign value
    (9) import -> . IMPORT STRING
    (7) dataStructure -> . if
    (49) functionDeclaration -> . datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE
    (54) prototype -> . VARIABLE LPAREN values RPAREN
    (55) prototype -> . VARIABLE LPAREN RPAREN
    (27) datatype -> . nullable_datatype
    (28) datatype -> . non_nullable_datatype
    (29) datatype -> . recordTypes
    (8) if -> . IF LPAREN value RPAREN LBRACE body RBRACE
    (26) nullable_datatype -> . non_nullable_datatype ACCEPT_NULL
    (15) non_nullable_datatype -> . INT_TYPE
    (16) non_nullable_datatype -> . DOUBLE_TYPE
    (17) non_nullable_datatype -> . NUM_TYPE
    (18) non_nullable_datatype -> . BOOL_TYPE
    (19) non_nullable_datatype -> . STRING_TYPE
    (20) non_nullable_datatype -> . LIST_TYPE
    (21) non_nullable_datatype -> . MAP_TYPE
    (22) non_nullable_datatype -> . SET_TYPE
    (23) non_nullable_datatype -> . RUNES_TYPE
    (24) non_nullable_datatype -> . SYMBOL_TYPE
    (25) non_nullable_datatype -> . VAR_TYPE
    (102) recordTypes -> . LPAREN multipleDatatypes RPAREN
    (103) recordTypes -> . LPAREN parameters RPAREN
    (104) recordTypes -> . LPAREN LBRACE recordTypeAnnotation RBRACE RPAREN

    VARIABLE        shift and go to state 12
    IMPORT          shift and go to state 14
    IF              shift and go to state 20
    INT_TYPE        shift and go to state 21
    DOUBLE_TYPE     shift and go to state 22
    NUM_TYPE        shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    LIST_TYPE       shift and go to state 26
    MAP_TYPE        shift and go to state 27
    SET_TYPE        shift and go to state 28
    RUNES_TYPE      shift and go to state 29
    SYMBOL_TYPE     shift and go to state 30
    VAR_TYPE        shift and go to state 31
    LPAREN          shift and go to state 16

    datatype                       shift and go to state 13
    body                           shift and go to state 173
    instruction                    shift and go to state 2
    noSemicolonStructure           shift and go to state 3
    functionCall                   shift and go to state 4
    variableDeclarationUninitialized shift and go to state 5
    variableDeclarationInitialized shift and go to state 6
    variableMutation               shift and go to state 7
    import                         shift and go to state 8
    dataStructure                  shift and go to state 9
    functionDeclaration            shift and go to state 10
    prototype                      shift and go to state 11
    if                             shift and go to state 15
    nullable_datatype              shift and go to state 17
    non_nullable_datatype          shift and go to state 18
    recordTypes                    shift and go to state 19

state 167

    (105) recordTypeAnnotation -> datatype VARIABLE COMMA recordTypeAnnotation .

    RBRACE          reduce using rule 105 (recordTypeAnnotation -> datatype VARIABLE COMMA recordTypeAnnotation .)


state 168

    (8) if -> IF LPAREN value RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 174


state 169

    (99) arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .

    PLUS            reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MINUS           reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    TIMES           reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    DIVIDE          reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MOD             reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    BITWISE_AND     reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    BITWISE_OR      reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    BITWISE_XOR     reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    LOGICAL_AND     reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    LOGICAL_OR      reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    EQUALS          reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    LESS_THAN       reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MORE_THAN       reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    LESS_EQUAL      reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MORE_EQUAL      reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    SEMICOLON       reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    COMMA           reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    RPAREN          reduce using rule 99 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)


state 170

    (101) bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .

    PLUS            reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    MINUS           reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    TIMES           reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    DIVIDE          reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    MOD             reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    BITWISE_AND     reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    BITWISE_OR      reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    BITWISE_XOR     reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    LOGICAL_AND     reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    LOGICAL_OR      reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    EQUALS          reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    LESS_THAN       reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    MORE_THAN       reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    LESS_EQUAL      reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    MORE_EQUAL      reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    SEMICOLON       reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    COMMA           reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)
    RPAREN          reduce using rule 101 (bitwiseExpression -> LPAREN value bitwiseOperator value RPAREN .)


state 171

    (97) logicExpression -> LPAREN value logicOperator value RPAREN .

    PLUS            reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    MINUS           reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    TIMES           reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    DIVIDE          reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    MOD             reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    BITWISE_AND     reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    BITWISE_OR      reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    BITWISE_XOR     reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    LOGICAL_AND     reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    LOGICAL_OR      reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    EQUALS          reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    LESS_THAN       reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    MORE_THAN       reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    LESS_EQUAL      reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    MORE_EQUAL      reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    SEMICOLON       reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    COMMA           reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)
    RPAREN          reduce using rule 97 (logicExpression -> LPAREN value logicOperator value RPAREN .)


state 172

    (95) comparison -> LPAREN value comparator value RPAREN .

    PLUS            reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    MINUS           reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    TIMES           reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    DIVIDE          reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    MOD             reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    BITWISE_AND     reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    BITWISE_OR      reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    BITWISE_XOR     reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    LOGICAL_AND     reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    LOGICAL_OR      reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    EQUALS          reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    LESS_THAN       reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    MORE_THAN       reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    LESS_EQUAL      reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    MORE_EQUAL      reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    SEMICOLON       reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    COMMA           reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)
    RPAREN          reduce using rule 95 (comparison -> LPAREN value comparator value RPAREN .)


state 173

    (49) functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 175


state 174

    (8) if -> IF LPAREN value RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    IMPORT          reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    INT_TYPE        reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    DOUBLE_TYPE     reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    NUM_TYPE        reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    BOOL_TYPE       reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    STRING_TYPE     reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    LIST_TYPE       reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    MAP_TYPE        reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    SET_TYPE        reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    RUNES_TYPE      reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    SYMBOL_TYPE     reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    VAR_TYPE        reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    LPAREN          reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 8 (if -> IF LPAREN value RPAREN LBRACE body RBRACE .)


state 175

    (49) functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    IMPORT          reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    INT_TYPE        reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    DOUBLE_TYPE     reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    NUM_TYPE        reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    BOOL_TYPE       reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    STRING_TYPE     reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    LIST_TYPE       reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    MAP_TYPE        reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    SET_TYPE        reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    RUNES_TYPE      reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    SYMBOL_TYPE     reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    VAR_TYPE        reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    LPAREN          reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 49 (functionDeclaration -> datatype VARIABLE LPAREN parameters RPAREN LBRACE body RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 134 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 134 resolved as shift
WARNING: shift/reduce conflict for MOD in state 134 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 134 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 134 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 134 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 134 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 134 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 134 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 134 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 135 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 135 resolved as shift
WARNING: shift/reduce conflict for MOD in state 135 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 135 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 135 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 135 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 135 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 135 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 135 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 135 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 135 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 135 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 136 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 136 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 136 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 136 resolved as shift
WARNING: shift/reduce conflict for MOD in state 136 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 136 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 136 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 136 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 136 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 136 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 136 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 136 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 136 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 136 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 137 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 137 resolved as shift
WARNING: shift/reduce conflict for MOD in state 137 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 137 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 137 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 137 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 137 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 137 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 137 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MOD in state 150 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 150 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 150 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 150 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 150 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 150 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 150 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 150 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 150 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 150 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 150 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 159 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 159 resolved as shift
WARNING: shift/reduce conflict for MOD in state 159 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 159 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 159 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 159 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 159 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 159 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 159 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 159 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 159 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 159 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 159 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 160 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 160 resolved as shift
WARNING: shift/reduce conflict for MOD in state 160 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 160 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 160 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 160 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 160 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 160 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 160 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 160 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 160 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 161 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 161 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 161 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 161 resolved as shift
WARNING: shift/reduce conflict for MOD in state 161 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 161 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 161 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 161 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 161 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 161 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 161 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 161 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 161 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 161 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 161 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 162 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 162 resolved as shift
WARNING: shift/reduce conflict for MOD in state 162 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 162 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 162 resolved as shift
WARNING: shift/reduce conflict for BITWISE_XOR in state 162 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 162 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 162 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 162 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 162 resolved as shift
WARNING: shift/reduce conflict for MORE_THAN in state 162 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 162 resolved as shift
WARNING: shift/reduce conflict for MORE_EQUAL in state 162 resolved as shift
