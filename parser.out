Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND_ASSIGN
    AS
    ASSERT
    ASYNC
    AWAIT
    BASE
    BITWISE_AND
    BITWISE_OR
    BITWISE_XOR
    BREAK
    CASE
    CATCH
    CLASS
    COLON
    COMMENT
    CONST
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DIV_ASSIGN
    DO
    DOLLAR
    DYNAMIC
    ELSE
    ENUM
    EQUALS
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FALSE
    FINAL
    FINALLY
    FOR
    FUNCTION
    GET
    HIDE
    IF
    IF_NULL
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    LATE
    LBRACE
    LBRACKET
    LESS_EQUAL
    LESS_THAN
    LIBRARY
    LOGICAL_AND
    LOGICAL_OR
    LSHIFT_ASSIGN
    MIXIN
    MOD
    MOD_ASSIGN
    MORE_EQUAL
    MORE_THAN
    MULTILINE_COMMENT
    MUL_ASSIGN
    NOT
    NOT_EQUAL
    NULL
    OF
    ON
    OPERATOR
    OR_ASSIGN
    PART
    RBRACE
    RBRACKET
    REQUIRED
    RETHROW
    RETURN
    RSHIFT_ASSIGN
    RUNSIGNED_SHIFT_ASSIGN
    SEALED
    SET
    SHOW
    STATIC
    SUB_ASSIGN
    SUM_ASSIGN
    SUPER
    SWITCH
    SYNC
    THIS
    THROW
    TRUE
    TRY
    TYPE
    TYPEDEF
    VOID
    WHEN
    WHILE
    WITH
    XOR_ASSIGN
    YIELD

Grammar

Rule 0     S' -> body
Rule 1     body -> instruction SEMICOLON body
Rule 2     body -> instruction SEMICOLON
Rule 3     instruction -> functionCall
Rule 4     instruction -> variableDeclaration
Rule 5     datatype -> INT_TYPE
Rule 6     datatype -> DOUBLE_TYPE
Rule 7     datatype -> NUM_TYPE
Rule 8     datatype -> BOOL_TYPE
Rule 9     datatype -> STRING_TYPE
Rule 10    datatype -> LIST_TYPE
Rule 11    datatype -> MAP_TYPE
Rule 12    datatype -> SET_TYPE
Rule 13    datatype -> RUNES_TYPE
Rule 14    datatype -> SYMBOL_TYPE
Rule 15    datatype -> VAR_TYPE
Rule 16    variableDeclaration -> datatype VARIABLE ASSIGN value
Rule 17    variableDeclaration -> datatype VARIABLE ASSIGN functionCall
Rule 18    functionCall -> prototype
Rule 19    functionCall -> object DOT prototype
Rule 20    values -> value COMMA values
Rule 21    values -> value
Rule 22    prototype -> FUNC_START values RPAREN
Rule 23    prototype -> FUNC_START RPAREN
Rule 24    object -> NEW prototype
Rule 25    number -> INTEGER
Rule 26    number -> DOUBLE
Rule 27    arithmeticOperator -> PLUS
Rule 28    arithmeticOperator -> MINUS
Rule 29    arithmeticOperator -> TIMES
Rule 30    arithmeticOperator -> DIVIDE
Rule 31    value -> number
Rule 32    value -> object
Rule 33    value -> arithmeticExpression
Rule 34    value -> STRING
Rule 35    value -> VARIABLE
Rule 36    value -> BOOLEAN
Rule 37    arithmeticExpression -> value arithmeticOperator value
Rule 38    arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN

Terminals, with rules where they appear

ABSTRACT             : 
AND_ASSIGN           : 
AS                   : 
ASSERT               : 
ASSIGN               : 16 17
ASYNC                : 
AWAIT                : 
BASE                 : 
BITWISE_AND          : 
BITWISE_OR           : 
BITWISE_XOR          : 
BOOLEAN              : 36
BOOL_TYPE            : 8
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 
COMMA                : 20
COMMENT              : 
CONST                : 
CONTINUE             : 
COVARIANT            : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 30
DIV_ASSIGN           : 
DO                   : 
DOLLAR               : 
DOT                  : 19
DOUBLE               : 26
DOUBLE_TYPE          : 6
DYNAMIC              : 
ELSE                 : 
ENUM                 : 
EQUALS               : 
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 
FINAL                : 
FINALLY              : 
FOR                  : 
FUNCTION             : 
FUNC_START           : 22 23
GET                  : 
HIDE                 : 
IF                   : 
IF_NULL              : 
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INTEGER              : 25
INTERFACE            : 
INT_TYPE             : 5
IS                   : 
LATE                 : 
LBRACE               : 
LBRACKET             : 
LESS_EQUAL           : 
LESS_THAN            : 
LIBRARY              : 
LIST_TYPE            : 10
LOGICAL_AND          : 
LOGICAL_OR           : 
LPAREN               : 38
LSHIFT_ASSIGN        : 
MAP_TYPE             : 11
MINUS                : 28
MIXIN                : 
MOD                  : 
MOD_ASSIGN           : 
MORE_EQUAL           : 
MORE_THAN            : 
MULTILINE_COMMENT    : 
MUL_ASSIGN           : 
NEW                  : 24
NOT                  : 
NOT_EQUAL            : 
NULL                 : 
NUM_TYPE             : 7
OF                   : 
ON                   : 
OPERATOR             : 
OR_ASSIGN            : 
PART                 : 
PLUS                 : 27
RBRACE               : 
RBRACKET             : 
REQUIRED             : 
RETHROW              : 
RETURN               : 
RPAREN               : 22 23 38
RSHIFT_ASSIGN        : 
RUNES_TYPE           : 13
RUNSIGNED_SHIFT_ASSIGN : 
SEALED               : 
SEMICOLON            : 1 2
SET                  : 
SET_TYPE             : 12
SHOW                 : 
STATIC               : 
STRING               : 34
STRING_TYPE          : 9
SUB_ASSIGN           : 
SUM_ASSIGN           : 
SUPER                : 
SWITCH               : 
SYMBOL_TYPE          : 14
SYNC                 : 
THIS                 : 
THROW                : 
TIMES                : 29
TRUE                 : 
TRY                  : 
TYPE                 : 
TYPEDEF              : 
VARIABLE             : 16 17 35
VAR_TYPE             : 15
VOID                 : 
WHEN                 : 
WHILE                : 
WITH                 : 
XOR_ASSIGN           : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmeticExpression : 33
arithmeticOperator   : 37 38
body                 : 1 0
datatype             : 16 17
functionCall         : 3 17
instruction          : 1 2
number               : 31
object               : 19 32
prototype            : 18 19 24
value                : 16 20 21 37 37 38 38
values               : 20 22
variableDeclaration  : 4

Parsing method: LALR

state 0

    (0) S' -> . body
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) instruction -> . functionCall
    (4) instruction -> . variableDeclaration
    (18) functionCall -> . prototype
    (19) functionCall -> . object DOT prototype
    (16) variableDeclaration -> . datatype VARIABLE ASSIGN value
    (17) variableDeclaration -> . datatype VARIABLE ASSIGN functionCall
    (22) prototype -> . FUNC_START values RPAREN
    (23) prototype -> . FUNC_START RPAREN
    (24) object -> . NEW prototype
    (5) datatype -> . INT_TYPE
    (6) datatype -> . DOUBLE_TYPE
    (7) datatype -> . NUM_TYPE
    (8) datatype -> . BOOL_TYPE
    (9) datatype -> . STRING_TYPE
    (10) datatype -> . LIST_TYPE
    (11) datatype -> . MAP_TYPE
    (12) datatype -> . SET_TYPE
    (13) datatype -> . RUNES_TYPE
    (14) datatype -> . SYMBOL_TYPE
    (15) datatype -> . VAR_TYPE

    FUNC_START      shift and go to state 8
    NEW             shift and go to state 9
    INT_TYPE        shift and go to state 10
    DOUBLE_TYPE     shift and go to state 11
    NUM_TYPE        shift and go to state 12
    BOOL_TYPE       shift and go to state 13
    STRING_TYPE     shift and go to state 14
    LIST_TYPE       shift and go to state 15
    MAP_TYPE        shift and go to state 16
    SET_TYPE        shift and go to state 17
    RUNES_TYPE      shift and go to state 18
    SYMBOL_TYPE     shift and go to state 19
    VAR_TYPE        shift and go to state 20

    body                           shift and go to state 1
    instruction                    shift and go to state 2
    functionCall                   shift and go to state 3
    variableDeclaration            shift and go to state 4
    prototype                      shift and go to state 5
    object                         shift and go to state 6
    datatype                       shift and go to state 7

state 1

    (0) S' -> body .



state 2

    (1) body -> instruction . SEMICOLON body
    (2) body -> instruction . SEMICOLON

    SEMICOLON       shift and go to state 21


state 3

    (3) instruction -> functionCall .

    SEMICOLON       reduce using rule 3 (instruction -> functionCall .)


state 4

    (4) instruction -> variableDeclaration .

    SEMICOLON       reduce using rule 4 (instruction -> variableDeclaration .)


state 5

    (18) functionCall -> prototype .

    SEMICOLON       reduce using rule 18 (functionCall -> prototype .)


state 6

    (19) functionCall -> object . DOT prototype

    DOT             shift and go to state 22


state 7

    (16) variableDeclaration -> datatype . VARIABLE ASSIGN value
    (17) variableDeclaration -> datatype . VARIABLE ASSIGN functionCall

    VARIABLE        shift and go to state 23


state 8

    (22) prototype -> FUNC_START . values RPAREN
    (23) prototype -> FUNC_START . RPAREN
    (20) values -> . value COMMA values
    (21) values -> . value
    (31) value -> . number
    (32) value -> . object
    (33) value -> . arithmeticExpression
    (34) value -> . STRING
    (35) value -> . VARIABLE
    (36) value -> . BOOLEAN
    (25) number -> . INTEGER
    (26) number -> . DOUBLE
    (24) object -> . NEW prototype
    (37) arithmeticExpression -> . value arithmeticOperator value
    (38) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN

    RPAREN          shift and go to state 25
    STRING          shift and go to state 30
    VARIABLE        shift and go to state 31
    BOOLEAN         shift and go to state 32
    INTEGER         shift and go to state 33
    DOUBLE          shift and go to state 34
    NEW             shift and go to state 9
    LPAREN          shift and go to state 35

    values                         shift and go to state 24
    value                          shift and go to state 26
    number                         shift and go to state 27
    object                         shift and go to state 28
    arithmeticExpression           shift and go to state 29

state 9

    (24) object -> NEW . prototype
    (22) prototype -> . FUNC_START values RPAREN
    (23) prototype -> . FUNC_START RPAREN

    FUNC_START      shift and go to state 8

    prototype                      shift and go to state 36

state 10

    (5) datatype -> INT_TYPE .

    VARIABLE        reduce using rule 5 (datatype -> INT_TYPE .)


state 11

    (6) datatype -> DOUBLE_TYPE .

    VARIABLE        reduce using rule 6 (datatype -> DOUBLE_TYPE .)


state 12

    (7) datatype -> NUM_TYPE .

    VARIABLE        reduce using rule 7 (datatype -> NUM_TYPE .)


state 13

    (8) datatype -> BOOL_TYPE .

    VARIABLE        reduce using rule 8 (datatype -> BOOL_TYPE .)


state 14

    (9) datatype -> STRING_TYPE .

    VARIABLE        reduce using rule 9 (datatype -> STRING_TYPE .)


state 15

    (10) datatype -> LIST_TYPE .

    VARIABLE        reduce using rule 10 (datatype -> LIST_TYPE .)


state 16

    (11) datatype -> MAP_TYPE .

    VARIABLE        reduce using rule 11 (datatype -> MAP_TYPE .)


state 17

    (12) datatype -> SET_TYPE .

    VARIABLE        reduce using rule 12 (datatype -> SET_TYPE .)


state 18

    (13) datatype -> RUNES_TYPE .

    VARIABLE        reduce using rule 13 (datatype -> RUNES_TYPE .)


state 19

    (14) datatype -> SYMBOL_TYPE .

    VARIABLE        reduce using rule 14 (datatype -> SYMBOL_TYPE .)


state 20

    (15) datatype -> VAR_TYPE .

    VARIABLE        reduce using rule 15 (datatype -> VAR_TYPE .)


state 21

    (1) body -> instruction SEMICOLON . body
    (2) body -> instruction SEMICOLON .
    (1) body -> . instruction SEMICOLON body
    (2) body -> . instruction SEMICOLON
    (3) instruction -> . functionCall
    (4) instruction -> . variableDeclaration
    (18) functionCall -> . prototype
    (19) functionCall -> . object DOT prototype
    (16) variableDeclaration -> . datatype VARIABLE ASSIGN value
    (17) variableDeclaration -> . datatype VARIABLE ASSIGN functionCall
    (22) prototype -> . FUNC_START values RPAREN
    (23) prototype -> . FUNC_START RPAREN
    (24) object -> . NEW prototype
    (5) datatype -> . INT_TYPE
    (6) datatype -> . DOUBLE_TYPE
    (7) datatype -> . NUM_TYPE
    (8) datatype -> . BOOL_TYPE
    (9) datatype -> . STRING_TYPE
    (10) datatype -> . LIST_TYPE
    (11) datatype -> . MAP_TYPE
    (12) datatype -> . SET_TYPE
    (13) datatype -> . RUNES_TYPE
    (14) datatype -> . SYMBOL_TYPE
    (15) datatype -> . VAR_TYPE

    $end            reduce using rule 2 (body -> instruction SEMICOLON .)
    FUNC_START      shift and go to state 8
    NEW             shift and go to state 9
    INT_TYPE        shift and go to state 10
    DOUBLE_TYPE     shift and go to state 11
    NUM_TYPE        shift and go to state 12
    BOOL_TYPE       shift and go to state 13
    STRING_TYPE     shift and go to state 14
    LIST_TYPE       shift and go to state 15
    MAP_TYPE        shift and go to state 16
    SET_TYPE        shift and go to state 17
    RUNES_TYPE      shift and go to state 18
    SYMBOL_TYPE     shift and go to state 19
    VAR_TYPE        shift and go to state 20

    instruction                    shift and go to state 2
    body                           shift and go to state 37
    functionCall                   shift and go to state 3
    variableDeclaration            shift and go to state 4
    prototype                      shift and go to state 5
    object                         shift and go to state 6
    datatype                       shift and go to state 7

state 22

    (19) functionCall -> object DOT . prototype
    (22) prototype -> . FUNC_START values RPAREN
    (23) prototype -> . FUNC_START RPAREN

    FUNC_START      shift and go to state 8

    prototype                      shift and go to state 38

state 23

    (16) variableDeclaration -> datatype VARIABLE . ASSIGN value
    (17) variableDeclaration -> datatype VARIABLE . ASSIGN functionCall

    ASSIGN          shift and go to state 39


state 24

    (22) prototype -> FUNC_START values . RPAREN

    RPAREN          shift and go to state 40


state 25

    (23) prototype -> FUNC_START RPAREN .

    SEMICOLON       reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    DOT             reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    COMMA           reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    PLUS            reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    MINUS           reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    TIMES           reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    DIVIDE          reduce using rule 23 (prototype -> FUNC_START RPAREN .)
    RPAREN          reduce using rule 23 (prototype -> FUNC_START RPAREN .)


state 26

    (20) values -> value . COMMA values
    (21) values -> value .
    (37) arithmeticExpression -> value . arithmeticOperator value
    (27) arithmeticOperator -> . PLUS
    (28) arithmeticOperator -> . MINUS
    (29) arithmeticOperator -> . TIMES
    (30) arithmeticOperator -> . DIVIDE

    COMMA           shift and go to state 41
    RPAREN          reduce using rule 21 (values -> value .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

    arithmeticOperator             shift and go to state 42

state 27

    (31) value -> number .

    COMMA           reduce using rule 31 (value -> number .)
    PLUS            reduce using rule 31 (value -> number .)
    MINUS           reduce using rule 31 (value -> number .)
    TIMES           reduce using rule 31 (value -> number .)
    DIVIDE          reduce using rule 31 (value -> number .)
    RPAREN          reduce using rule 31 (value -> number .)
    SEMICOLON       reduce using rule 31 (value -> number .)


state 28

    (32) value -> object .

    COMMA           reduce using rule 32 (value -> object .)
    PLUS            reduce using rule 32 (value -> object .)
    MINUS           reduce using rule 32 (value -> object .)
    TIMES           reduce using rule 32 (value -> object .)
    DIVIDE          reduce using rule 32 (value -> object .)
    RPAREN          reduce using rule 32 (value -> object .)
    SEMICOLON       reduce using rule 32 (value -> object .)


state 29

    (33) value -> arithmeticExpression .

    COMMA           reduce using rule 33 (value -> arithmeticExpression .)
    PLUS            reduce using rule 33 (value -> arithmeticExpression .)
    MINUS           reduce using rule 33 (value -> arithmeticExpression .)
    TIMES           reduce using rule 33 (value -> arithmeticExpression .)
    DIVIDE          reduce using rule 33 (value -> arithmeticExpression .)
    RPAREN          reduce using rule 33 (value -> arithmeticExpression .)
    SEMICOLON       reduce using rule 33 (value -> arithmeticExpression .)


state 30

    (34) value -> STRING .

    COMMA           reduce using rule 34 (value -> STRING .)
    PLUS            reduce using rule 34 (value -> STRING .)
    MINUS           reduce using rule 34 (value -> STRING .)
    TIMES           reduce using rule 34 (value -> STRING .)
    DIVIDE          reduce using rule 34 (value -> STRING .)
    RPAREN          reduce using rule 34 (value -> STRING .)
    SEMICOLON       reduce using rule 34 (value -> STRING .)


state 31

    (35) value -> VARIABLE .

    COMMA           reduce using rule 35 (value -> VARIABLE .)
    PLUS            reduce using rule 35 (value -> VARIABLE .)
    MINUS           reduce using rule 35 (value -> VARIABLE .)
    TIMES           reduce using rule 35 (value -> VARIABLE .)
    DIVIDE          reduce using rule 35 (value -> VARIABLE .)
    RPAREN          reduce using rule 35 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 35 (value -> VARIABLE .)


state 32

    (36) value -> BOOLEAN .

    COMMA           reduce using rule 36 (value -> BOOLEAN .)
    PLUS            reduce using rule 36 (value -> BOOLEAN .)
    MINUS           reduce using rule 36 (value -> BOOLEAN .)
    TIMES           reduce using rule 36 (value -> BOOLEAN .)
    DIVIDE          reduce using rule 36 (value -> BOOLEAN .)
    RPAREN          reduce using rule 36 (value -> BOOLEAN .)
    SEMICOLON       reduce using rule 36 (value -> BOOLEAN .)


state 33

    (25) number -> INTEGER .

    COMMA           reduce using rule 25 (number -> INTEGER .)
    PLUS            reduce using rule 25 (number -> INTEGER .)
    MINUS           reduce using rule 25 (number -> INTEGER .)
    TIMES           reduce using rule 25 (number -> INTEGER .)
    DIVIDE          reduce using rule 25 (number -> INTEGER .)
    RPAREN          reduce using rule 25 (number -> INTEGER .)
    SEMICOLON       reduce using rule 25 (number -> INTEGER .)


state 34

    (26) number -> DOUBLE .

    COMMA           reduce using rule 26 (number -> DOUBLE .)
    PLUS            reduce using rule 26 (number -> DOUBLE .)
    MINUS           reduce using rule 26 (number -> DOUBLE .)
    TIMES           reduce using rule 26 (number -> DOUBLE .)
    DIVIDE          reduce using rule 26 (number -> DOUBLE .)
    RPAREN          reduce using rule 26 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 26 (number -> DOUBLE .)


state 35

    (38) arithmeticExpression -> LPAREN . value arithmeticOperator value RPAREN
    (31) value -> . number
    (32) value -> . object
    (33) value -> . arithmeticExpression
    (34) value -> . STRING
    (35) value -> . VARIABLE
    (36) value -> . BOOLEAN
    (25) number -> . INTEGER
    (26) number -> . DOUBLE
    (24) object -> . NEW prototype
    (37) arithmeticExpression -> . value arithmeticOperator value
    (38) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN

    STRING          shift and go to state 30
    VARIABLE        shift and go to state 31
    BOOLEAN         shift and go to state 32
    INTEGER         shift and go to state 33
    DOUBLE          shift and go to state 34
    NEW             shift and go to state 9
    LPAREN          shift and go to state 35

    value                          shift and go to state 47
    number                         shift and go to state 27
    object                         shift and go to state 28
    arithmeticExpression           shift and go to state 29

state 36

    (24) object -> NEW prototype .

    DOT             reduce using rule 24 (object -> NEW prototype .)
    COMMA           reduce using rule 24 (object -> NEW prototype .)
    PLUS            reduce using rule 24 (object -> NEW prototype .)
    MINUS           reduce using rule 24 (object -> NEW prototype .)
    TIMES           reduce using rule 24 (object -> NEW prototype .)
    DIVIDE          reduce using rule 24 (object -> NEW prototype .)
    RPAREN          reduce using rule 24 (object -> NEW prototype .)
    SEMICOLON       reduce using rule 24 (object -> NEW prototype .)


state 37

    (1) body -> instruction SEMICOLON body .

    $end            reduce using rule 1 (body -> instruction SEMICOLON body .)


state 38

    (19) functionCall -> object DOT prototype .

    SEMICOLON       reduce using rule 19 (functionCall -> object DOT prototype .)


state 39

    (16) variableDeclaration -> datatype VARIABLE ASSIGN . value
    (17) variableDeclaration -> datatype VARIABLE ASSIGN . functionCall
    (31) value -> . number
    (32) value -> . object
    (33) value -> . arithmeticExpression
    (34) value -> . STRING
    (35) value -> . VARIABLE
    (36) value -> . BOOLEAN
    (18) functionCall -> . prototype
    (19) functionCall -> . object DOT prototype
    (25) number -> . INTEGER
    (26) number -> . DOUBLE
    (24) object -> . NEW prototype
    (37) arithmeticExpression -> . value arithmeticOperator value
    (38) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN
    (22) prototype -> . FUNC_START values RPAREN
    (23) prototype -> . FUNC_START RPAREN

    STRING          shift and go to state 30
    VARIABLE        shift and go to state 31
    BOOLEAN         shift and go to state 32
    INTEGER         shift and go to state 33
    DOUBLE          shift and go to state 34
    NEW             shift and go to state 9
    LPAREN          shift and go to state 35
    FUNC_START      shift and go to state 8

    value                          shift and go to state 48
    functionCall                   shift and go to state 49
    number                         shift and go to state 27
    object                         shift and go to state 50
    arithmeticExpression           shift and go to state 29
    prototype                      shift and go to state 5

state 40

    (22) prototype -> FUNC_START values RPAREN .

    SEMICOLON       reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    DOT             reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    COMMA           reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    PLUS            reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    MINUS           reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    TIMES           reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    DIVIDE          reduce using rule 22 (prototype -> FUNC_START values RPAREN .)
    RPAREN          reduce using rule 22 (prototype -> FUNC_START values RPAREN .)


state 41

    (20) values -> value COMMA . values
    (20) values -> . value COMMA values
    (21) values -> . value
    (31) value -> . number
    (32) value -> . object
    (33) value -> . arithmeticExpression
    (34) value -> . STRING
    (35) value -> . VARIABLE
    (36) value -> . BOOLEAN
    (25) number -> . INTEGER
    (26) number -> . DOUBLE
    (24) object -> . NEW prototype
    (37) arithmeticExpression -> . value arithmeticOperator value
    (38) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN

    STRING          shift and go to state 30
    VARIABLE        shift and go to state 31
    BOOLEAN         shift and go to state 32
    INTEGER         shift and go to state 33
    DOUBLE          shift and go to state 34
    NEW             shift and go to state 9
    LPAREN          shift and go to state 35

    value                          shift and go to state 26
    values                         shift and go to state 51
    number                         shift and go to state 27
    object                         shift and go to state 28
    arithmeticExpression           shift and go to state 29

state 42

    (37) arithmeticExpression -> value arithmeticOperator . value
    (31) value -> . number
    (32) value -> . object
    (33) value -> . arithmeticExpression
    (34) value -> . STRING
    (35) value -> . VARIABLE
    (36) value -> . BOOLEAN
    (25) number -> . INTEGER
    (26) number -> . DOUBLE
    (24) object -> . NEW prototype
    (37) arithmeticExpression -> . value arithmeticOperator value
    (38) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN

    STRING          shift and go to state 30
    VARIABLE        shift and go to state 31
    BOOLEAN         shift and go to state 32
    INTEGER         shift and go to state 33
    DOUBLE          shift and go to state 34
    NEW             shift and go to state 9
    LPAREN          shift and go to state 35

    value                          shift and go to state 52
    number                         shift and go to state 27
    object                         shift and go to state 28
    arithmeticExpression           shift and go to state 29

state 43

    (27) arithmeticOperator -> PLUS .

    STRING          reduce using rule 27 (arithmeticOperator -> PLUS .)
    VARIABLE        reduce using rule 27 (arithmeticOperator -> PLUS .)
    BOOLEAN         reduce using rule 27 (arithmeticOperator -> PLUS .)
    INTEGER         reduce using rule 27 (arithmeticOperator -> PLUS .)
    DOUBLE          reduce using rule 27 (arithmeticOperator -> PLUS .)
    NEW             reduce using rule 27 (arithmeticOperator -> PLUS .)
    LPAREN          reduce using rule 27 (arithmeticOperator -> PLUS .)


state 44

    (28) arithmeticOperator -> MINUS .

    STRING          reduce using rule 28 (arithmeticOperator -> MINUS .)
    VARIABLE        reduce using rule 28 (arithmeticOperator -> MINUS .)
    BOOLEAN         reduce using rule 28 (arithmeticOperator -> MINUS .)
    INTEGER         reduce using rule 28 (arithmeticOperator -> MINUS .)
    DOUBLE          reduce using rule 28 (arithmeticOperator -> MINUS .)
    NEW             reduce using rule 28 (arithmeticOperator -> MINUS .)
    LPAREN          reduce using rule 28 (arithmeticOperator -> MINUS .)


state 45

    (29) arithmeticOperator -> TIMES .

    STRING          reduce using rule 29 (arithmeticOperator -> TIMES .)
    VARIABLE        reduce using rule 29 (arithmeticOperator -> TIMES .)
    BOOLEAN         reduce using rule 29 (arithmeticOperator -> TIMES .)
    INTEGER         reduce using rule 29 (arithmeticOperator -> TIMES .)
    DOUBLE          reduce using rule 29 (arithmeticOperator -> TIMES .)
    NEW             reduce using rule 29 (arithmeticOperator -> TIMES .)
    LPAREN          reduce using rule 29 (arithmeticOperator -> TIMES .)


state 46

    (30) arithmeticOperator -> DIVIDE .

    STRING          reduce using rule 30 (arithmeticOperator -> DIVIDE .)
    VARIABLE        reduce using rule 30 (arithmeticOperator -> DIVIDE .)
    BOOLEAN         reduce using rule 30 (arithmeticOperator -> DIVIDE .)
    INTEGER         reduce using rule 30 (arithmeticOperator -> DIVIDE .)
    DOUBLE          reduce using rule 30 (arithmeticOperator -> DIVIDE .)
    NEW             reduce using rule 30 (arithmeticOperator -> DIVIDE .)
    LPAREN          reduce using rule 30 (arithmeticOperator -> DIVIDE .)


state 47

    (38) arithmeticExpression -> LPAREN value . arithmeticOperator value RPAREN
    (37) arithmeticExpression -> value . arithmeticOperator value
    (27) arithmeticOperator -> . PLUS
    (28) arithmeticOperator -> . MINUS
    (29) arithmeticOperator -> . TIMES
    (30) arithmeticOperator -> . DIVIDE

    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

    arithmeticOperator             shift and go to state 53

state 48

    (16) variableDeclaration -> datatype VARIABLE ASSIGN value .
    (37) arithmeticExpression -> value . arithmeticOperator value
    (27) arithmeticOperator -> . PLUS
    (28) arithmeticOperator -> . MINUS
    (29) arithmeticOperator -> . TIMES
    (30) arithmeticOperator -> . DIVIDE

    SEMICOLON       reduce using rule 16 (variableDeclaration -> datatype VARIABLE ASSIGN value .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

    arithmeticOperator             shift and go to state 42

state 49

    (17) variableDeclaration -> datatype VARIABLE ASSIGN functionCall .

    SEMICOLON       reduce using rule 17 (variableDeclaration -> datatype VARIABLE ASSIGN functionCall .)


state 50

    (32) value -> object .
    (19) functionCall -> object . DOT prototype

    PLUS            reduce using rule 32 (value -> object .)
    MINUS           reduce using rule 32 (value -> object .)
    TIMES           reduce using rule 32 (value -> object .)
    DIVIDE          reduce using rule 32 (value -> object .)
    SEMICOLON       reduce using rule 32 (value -> object .)
    DOT             shift and go to state 22


state 51

    (20) values -> value COMMA values .

    RPAREN          reduce using rule 20 (values -> value COMMA values .)


state 52

    (37) arithmeticExpression -> value arithmeticOperator value .
    (37) arithmeticExpression -> value . arithmeticOperator value
    (27) arithmeticOperator -> . PLUS
    (28) arithmeticOperator -> . MINUS
    (29) arithmeticOperator -> . TIMES
    (30) arithmeticOperator -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    COMMA           reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .)
    RPAREN          reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .)
    SEMICOLON       reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

  ! PLUS            [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MINUS           [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! TIMES           [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! DIVIDE          [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]

    arithmeticOperator             shift and go to state 42

state 53

    (38) arithmeticExpression -> LPAREN value arithmeticOperator . value RPAREN
    (37) arithmeticExpression -> value arithmeticOperator . value
    (31) value -> . number
    (32) value -> . object
    (33) value -> . arithmeticExpression
    (34) value -> . STRING
    (35) value -> . VARIABLE
    (36) value -> . BOOLEAN
    (25) number -> . INTEGER
    (26) number -> . DOUBLE
    (24) object -> . NEW prototype
    (37) arithmeticExpression -> . value arithmeticOperator value
    (38) arithmeticExpression -> . LPAREN value arithmeticOperator value RPAREN

    STRING          shift and go to state 30
    VARIABLE        shift and go to state 31
    BOOLEAN         shift and go to state 32
    INTEGER         shift and go to state 33
    DOUBLE          shift and go to state 34
    NEW             shift and go to state 9
    LPAREN          shift and go to state 35

    value                          shift and go to state 54
    number                         shift and go to state 27
    object                         shift and go to state 28
    arithmeticExpression           shift and go to state 29

state 54

    (38) arithmeticExpression -> LPAREN value arithmeticOperator value . RPAREN
    (37) arithmeticExpression -> value arithmeticOperator value .
    (37) arithmeticExpression -> value . arithmeticOperator value
    (27) arithmeticOperator -> . PLUS
    (28) arithmeticOperator -> . MINUS
    (29) arithmeticOperator -> . TIMES
    (30) arithmeticOperator -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    RPAREN          shift and go to state 55
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

  ! PLUS            [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! MINUS           [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! TIMES           [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]
  ! DIVIDE          [ reduce using rule 37 (arithmeticExpression -> value arithmeticOperator value .) ]

    arithmeticOperator             shift and go to state 42

state 55

    (38) arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .

    COMMA           reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    PLUS            reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    MINUS           reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    TIMES           reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    DIVIDE          reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    RPAREN          reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)
    SEMICOLON       reduce using rule 38 (arithmeticExpression -> LPAREN value arithmeticOperator value RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 52 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 52 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 52 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 52 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 54 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 54 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 54 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 54 resolved as shift
